
Blutooth_Test_Prog_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000082  00800100  00000530  000005c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000530  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  00800182  00800182  00000646  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000646  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000104  00000000  00000000  00000686  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000b2f  00000000  00000000  0000078a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000376  00000000  00000000  000012b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000007ff  00000000  00000000  0000162f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000120  00000000  00000000  00001e30  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000319  00000000  00000000  00001f50  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000003f8  00000000  00000000  00002269  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00002661  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 67 00 	jmp	0xce	; 0xce <__vector_18>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 e3       	ldi	r30, 0x30	; 48
  a0:	f5 e0       	ldi	r31, 0x05	; 5
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 38       	cpi	r26, 0x82	; 130
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	a2 e8       	ldi	r26, 0x82	; 130
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ab 38       	cpi	r26, 0x8B	; 139
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 1c 01 	call	0x238	; 0x238 <main>
  c6:	0c 94 96 02 	jmp	0x52c	; 0x52c <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <__vector_18>:


// UART1 수신 인터럽트 서비스 프로그램

ISR(  USART0_RX_vect )
{
  ce:	1f 92       	push	r1
  d0:	0f 92       	push	r0
  d2:	0f b6       	in	r0, 0x3f	; 63
  d4:	0f 92       	push	r0
  d6:	11 24       	eor	r1, r1
  d8:	8f 93       	push	r24

    rdata = UDR0; 
  da:	8c b1       	in	r24, 0x0c	; 12
  dc:	80 93 87 01 	sts	0x0187, r24
 
    SerialPutChar( rdata);           // Echo  수신된 데이터를 바로 송신하여 수신된 데이터가 정확한지 확인 
  e0:	80 91 87 01 	lds	r24, 0x0187
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  e4:	5d 9b       	sbis	0x0b, 5	; 11
  e6:	fe cf       	rjmp	.-4      	; 0xe4 <__vector_18+0x16>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
  e8:	8c b9       	out	0x0c, r24	; 12
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  ea:	5d 9b       	sbis	0x0b, 5	; 11
  ec:	fe cf       	rjmp	.-4      	; 0xea <__vector_18+0x1c>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
  ee:	8a e0       	ldi	r24, 0x0A	; 10
  f0:	8c b9       	out	0x0c, r24	; 12
    rdata = UDR0; 
 
    SerialPutChar( rdata);           // Echo  수신된 데이터를 바로 송신하여 수신된 데이터가 정확한지 확인 
    SerialPutChar('\n');             // 휴대폰으로 데이터 전송시 Line Feed('\n')를 항상 끝에 전송해야함

    recv_cnt++ ;                     // 수신된 데이터 바이트수 저장
  f2:	80 91 88 01 	lds	r24, 0x0188
  f6:	8f 5f       	subi	r24, 0xFF	; 255
  f8:	80 93 88 01 	sts	0x0188, r24

    new_recv_flag = 1;               // 새 문자(명령) 수신 플래그 Set
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	80 93 89 01 	sts	0x0189, r24

}
 102:	8f 91       	pop	r24
 104:	0f 90       	pop	r0
 106:	0f be       	out	0x3f, r0	; 63
 108:	0f 90       	pop	r0
 10a:	1f 90       	pop	r1
 10c:	18 95       	reti

0000010e <init_serial>:

// UART1 통신 초기화 프로그램 

void init_serial(void)
{
    UCSR0A = 0x00;                    //초기화
 10e:	1b b8       	out	0x0b, r1	; 11
    UCSR0B = 0x18  ;                  //송수신허용,  송수신 인터럽트 금지
 110:	88 e1       	ldi	r24, 0x18	; 24
 112:	8a b9       	out	0x0a, r24	; 10
    UCSR0C = 0x06;                    //데이터 전송비트 수 8비트로 설정.
 114:	86 e0       	ldi	r24, 0x06	; 6
 116:	80 93 95 00 	sts	0x0095, r24
    
    UBRR0H = 0x00;
 11a:	10 92 90 00 	sts	0x0090, r1
    UBRR0L = 103;                     //Baud Rate 9600 
 11e:	87 e6       	ldi	r24, 0x67	; 103
 120:	89 b9       	out	0x09, r24	; 9
}
 122:	08 95       	ret

00000124 <SerialPutChar>:
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 124:	5d 9b       	sbis	0x0b, 5	; 11
 126:	fe cf       	rjmp	.-4      	; 0x124 <SerialPutChar>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 128:	8c b9       	out	0x0c, r24	; 12
}
 12a:	08 95       	ret

0000012c <SerialPutString>:
// 문자열을 송신한다.
// 입력   : str - 송신한 문자열을 저장할 버퍼의 주소
//=============================================

 void SerialPutString(char *str)
 {
 12c:	fc 01       	movw	r30, r24
 12e:	04 c0       	rjmp	.+8      	; 0x138 <SerialPutString+0xc>
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 130:	5d 9b       	sbis	0x0b, 5	; 11
 132:	fe cf       	rjmp	.-4      	; 0x130 <SerialPutString+0x4>
 {

    while(*str != '\0')         // 수신된 문자가 Null 문자( 0x00 )가 아니면 
    {

        SerialPutChar(*str++);
 134:	31 96       	adiw	r30, 0x01	; 1
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 136:	8c b9       	out	0x0c, r24	; 12
//=============================================

 void SerialPutString(char *str)
 {

    while(*str != '\0')         // 수신된 문자가 Null 문자( 0x00 )가 아니면 
 138:	80 81       	ld	r24, Z
 13a:	88 23       	and	r24, r24
 13c:	c9 f7       	brne	.-14     	; 0x130 <SerialPutString+0x4>
    {

        SerialPutChar(*str++);
    }
}
 13e:	08 95       	ret

00000140 <HexToDec>:
}



void HexToDec(unsigned short num, unsigned short radix)
{
 140:	0f 93       	push	r16
 142:	1f 93       	push	r17
 144:	cf 93       	push	r28
 146:	df 93       	push	r29
 148:	9c 01       	movw	r18, r24
 14a:	8b 01       	movw	r16, r22
	int j = 0;

	for(j=0; j<5; j++) cnumber[j] = 0;
 14c:	10 92 82 01 	sts	0x0182, r1
 150:	10 92 83 01 	sts	0x0183, r1
 154:	10 92 84 01 	sts	0x0184, r1
 158:	10 92 85 01 	sts	0x0185, r1
 15c:	10 92 86 01 	sts	0x0186, r1
 160:	c0 e0       	ldi	r28, 0x00	; 0
 162:	d0 e0       	ldi	r29, 0x00	; 0

	j=0;

	do
	{
		cnumber[j++] = num % radix;
 164:	c9 01       	movw	r24, r18
 166:	b8 01       	movw	r22, r16
 168:	0e 94 82 02 	call	0x504	; 0x504 <__udivmodhi4>
 16c:	fe 01       	movw	r30, r28
 16e:	ee 57       	subi	r30, 0x7E	; 126
 170:	fe 4f       	sbci	r31, 0xFE	; 254
 172:	80 83       	st	Z, r24
 174:	21 96       	adiw	r28, 0x01	; 1
		num /= radix;
 176:	c9 01       	movw	r24, r18
 178:	b8 01       	movw	r22, r16
 17a:	0e 94 82 02 	call	0x504	; 0x504 <__udivmodhi4>
 17e:	9b 01       	movw	r18, r22

	}while(num);
 180:	61 15       	cp	r22, r1
 182:	71 05       	cpc	r23, r1
 184:	79 f7       	brne	.-34     	; 0x164 <HexToDec+0x24>
}
 186:	df 91       	pop	r29
 188:	cf 91       	pop	r28
 18a:	1f 91       	pop	r17
 18c:	0f 91       	pop	r16
 18e:	08 95       	ret

00000190 <NumToAsc>:


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 190:	8a 30       	cpi	r24, 0x0A	; 10
 192:	10 f0       	brcs	.+4      	; 0x198 <NumToAsc+0x8>
 194:	89 5c       	subi	r24, 0xC9	; 201
 196:	08 95       	ret
	else	      Num += 0x30;
 198:	80 5d       	subi	r24, 0xD0	; 208

	return Num;
}
 19a:	08 95       	ret

0000019c <msec_delay>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 19c:	20 ea       	ldi	r18, 0xA0	; 160
 19e:	3f e0       	ldi	r19, 0x0F	; 15
 1a0:	04 c0       	rjmp	.+8      	; 0x1aa <msec_delay+0xe>
 1a2:	f9 01       	movw	r30, r18
 1a4:	31 97       	sbiw	r30, 0x01	; 1
 1a6:	f1 f7       	brne	.-4      	; 0x1a4 <msec_delay+0x8>



void msec_delay( int n )
{
	for(; n> 0 ; n-- )   _delay_ms(1); 
 1a8:	01 97       	sbiw	r24, 0x01	; 1
 1aa:	18 16       	cp	r1, r24
 1ac:	19 06       	cpc	r1, r25
 1ae:	cc f3       	brlt	.-14     	; 0x1a2 <msec_delay+0x6>
}
 1b0:	08 95       	ret

000001b2 <Display_Number_LCD>:
}



void Display_Number_LCD( unsigned int num, unsigned char digit )       // 부호없는 정수형 변수를 10진수 형태로 LCD 에 디스플레이 
{
 1b2:	1f 93       	push	r17
 1b4:	16 2f       	mov	r17, r22

	HexToDec( num, 10); //10진수로 변환 
 1b6:	6a e0       	ldi	r22, 0x0A	; 10
 1b8:	70 e0       	ldi	r23, 0x00	; 0
 1ba:	0e 94 a0 00 	call	0x140	; 0x140 <HexToDec>

	if( digit == 0 )     digit = 1 ;
 1be:	11 23       	and	r17, r17
 1c0:	81 f1       	breq	.+96     	; 0x222 <Display_Number_LCD+0x70>
	if( digit > 5 )      digit = 5 ;
 1c2:	16 30       	cpi	r17, 0x06	; 6
 1c4:	10 f0       	brcs	.+4      	; 0x1ca <Display_Number_LCD+0x18>
 1c6:	15 e0       	ldi	r17, 0x05	; 5
 1c8:	02 c0       	rjmp	.+4      	; 0x1ce <Display_Number_LCD+0x1c>
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
 1ca:	15 30       	cpi	r17, 0x05	; 5
 1cc:	49 f4       	brne	.+18     	; 0x1e0 <Display_Number_LCD+0x2e>
 1ce:	80 91 86 01 	lds	r24, 0x0186


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 1d2:	8a 30       	cpi	r24, 0x0A	; 10
 1d4:	10 f0       	brcs	.+4      	; 0x1da <Display_Number_LCD+0x28>
 1d6:	89 5c       	subi	r24, 0xC9	; 201
 1d8:	01 c0       	rjmp	.+2      	; 0x1dc <Display_Number_LCD+0x2a>
	else	      Num += 0x30;
 1da:	80 5d       	subi	r24, 0xD0	; 208
	HexToDec( num, 10); //10진수로 변환 

	if( digit == 0 )     digit = 1 ;
	if( digit > 5 )      digit = 5 ;
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
 1dc:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 
 1e0:	14 30       	cpi	r17, 0x04	; 4
 1e2:	48 f0       	brcs	.+18     	; 0x1f6 <Display_Number_LCD+0x44>
 1e4:	80 91 85 01 	lds	r24, 0x0185


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 1e8:	8a 30       	cpi	r24, 0x0A	; 10
 1ea:	10 f0       	brcs	.+4      	; 0x1f0 <Display_Number_LCD+0x3e>
 1ec:	89 5c       	subi	r24, 0xC9	; 201
 1ee:	01 c0       	rjmp	.+2      	; 0x1f2 <Display_Number_LCD+0x40>
	else	      Num += 0x30;
 1f0:	80 5d       	subi	r24, 0xD0	; 208
	if( digit == 0 )     digit = 1 ;
	if( digit > 5 )      digit = 5 ;
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 
 1f2:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 
 1f6:	13 30       	cpi	r17, 0x03	; 3
 1f8:	48 f0       	brcs	.+18     	; 0x20c <Display_Number_LCD+0x5a>
 1fa:	80 91 84 01 	lds	r24, 0x0184


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 1fe:	8a 30       	cpi	r24, 0x0A	; 10
 200:	10 f0       	brcs	.+4      	; 0x206 <Display_Number_LCD+0x54>
 202:	89 5c       	subi	r24, 0xC9	; 201
 204:	01 c0       	rjmp	.+2      	; 0x208 <Display_Number_LCD+0x56>
	else	      Num += 0x30;
 206:	80 5d       	subi	r24, 0xD0	; 208
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 
 208:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이
 20c:	11 30       	cpi	r17, 0x01	; 1
 20e:	49 f0       	breq	.+18     	; 0x222 <Display_Number_LCD+0x70>
 210:	80 91 83 01 	lds	r24, 0x0183


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 214:	8a 30       	cpi	r24, 0x0A	; 10
 216:	10 f0       	brcs	.+4      	; 0x21c <Display_Number_LCD+0x6a>
 218:	89 5c       	subi	r24, 0xC9	; 201
 21a:	01 c0       	rjmp	.+2      	; 0x21e <Display_Number_LCD+0x6c>
	else	      Num += 0x30;
 21c:	80 5d       	subi	r24, 0xD0	; 208
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이
 21e:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>

	if( digit >= 1 )     LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 222:	80 91 82 01 	lds	r24, 0x0182


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 226:	8a 30       	cpi	r24, 0x0A	; 10
 228:	10 f0       	brcs	.+4      	; 0x22e <Display_Number_LCD+0x7c>
 22a:	89 5c       	subi	r24, 0xC9	; 201
 22c:	01 c0       	rjmp	.+2      	; 0x230 <Display_Number_LCD+0x7e>
	else	      Num += 0x30;
 22e:	80 5d       	subi	r24, 0xD0	; 208

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이

	if( digit >= 1 )     LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 230:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>

}
 234:	1f 91       	pop	r17
 236:	08 95       	ret

00000238 <main>:

/********************************************************************************************************************
                                      					main
********************************************************************************************************************/
int main(void)
{ 	  
 238:	0f 93       	push	r16
 23a:	1f 93       	push	r17
 

	 DDRB |= 0x10 ; 	// LED (PB4 ) :출력설정	
 23c:	bc 9a       	sbi	0x17, 4	; 23

	 PORTB |= 0x10 ;    // LED OFF
 23e:	c4 9a       	sbi	0x18, 4	; 24

// UART1 통신 초기화 프로그램 

void init_serial(void)
{
    UCSR0A = 0x00;                    //초기화
 240:	1b b8       	out	0x0b, r1	; 11
    UCSR0B = 0x18  ;                  //송수신허용,  송수신 인터럽트 금지
 242:	88 e1       	ldi	r24, 0x18	; 24
 244:	8a b9       	out	0x0a, r24	; 10
    UCSR0C = 0x06;                    //데이터 전송비트 수 8비트로 설정.
 246:	86 e0       	ldi	r24, 0x06	; 6
 248:	80 93 95 00 	sts	0x0095, r24
    
    UBRR0H = 0x00;
 24c:	10 92 90 00 	sts	0x0090, r1
    UBRR0L = 103;                     //Baud Rate 9600 
 250:	87 e6       	ldi	r24, 0x67	; 103
 252:	89 b9       	out	0x09, r24	; 9

	 PORTB |= 0x10 ;    // LED OFF

     init_serial() ;    // Serial Port (USART1) 초기화

     LcdInit();         // LCD 초기화 
 254:	0e 94 3f 02 	call	0x47e	; 0x47e <LcdInit>


     UCSR0B |=  0x80  ;      // UART1 송신(RX) 완료 인터럽트 허용
 258:	57 9a       	sbi	0x0a, 7	; 10
	 sei() ;                 // 전역인터럽트허용
 25a:	78 94       	sei


     LcdCommand( ALLCLR ) ;    // LCD Clear
 25c:	81 e0       	ldi	r24, 0x01	; 1
 25e:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
  	 LcdMove(0,0);    
 262:	80 e0       	ldi	r24, 0x00	; 0
 264:	60 e0       	ldi	r22, 0x00	; 0
 266:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
	 LcdPuts("Bluetooth Prog"); 
 26a:	80 e0       	ldi	r24, 0x00	; 0
 26c:	91 e0       	ldi	r25, 0x01	; 1
 26e:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <LcdPuts>
 
  	 LcdMove(1,0);    
 272:	81 e0       	ldi	r24, 0x01	; 1
 274:	60 e0       	ldi	r22, 0x00	; 0
 276:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
	 LcdPuts("Send Command."); 
 27a:	8f e0       	ldi	r24, 0x0F	; 15
 27c:	91 e0       	ldi	r25, 0x01	; 1
 27e:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <LcdPuts>
           }

      ////////////////////////////////////////////////////////////////


		   rdata = 0xFF;                           // 수신된 명령을 초기값으로 리셋
 282:	0f ef       	ldi	r16, 0xFF	; 255
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 284:	1a e0       	ldi	r17, 0x0A	; 10
	 LcdPuts("Send Command."); 

	  while(1)
	  {

         if( new_recv_flag == 1 )      // 1 문자 수신완료 시 
 286:	80 91 89 01 	lds	r24, 0x0189
 28a:	81 30       	cpi	r24, 0x01	; 1
 28c:	e1 f7       	brne	.-8      	; 0x286 <main+0x4e>
		 { 


		    if( Command_Error_Flag == 1 )    // 이전 명령에 오류가 있었으면
 28e:	80 91 8a 01 	lds	r24, 0x018A
 292:	81 30       	cpi	r24, 0x01	; 1
 294:	11 f4       	brne	.+4      	; 0x29a <main+0x62>
			{  
			      Command_Error_Flag = 0 ;     // 이전 Command_Error_Flag 리셋 
 296:	10 92 8a 01 	sts	0x018A, r1
            }

            /////  수신된 바이트수(변수 값) LCD 디스플레이  /////////////////

            LcdCommand( ALLCLR ) ;    // LCD Clear
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>

		    LcdMove(0,0);    
 2a0:	80 e0       	ldi	r24, 0x00	; 0
 2a2:	60 e0       	ldi	r22, 0x00	; 0
 2a4:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
		    LcdPuts("Recv cnt = "); 
 2a8:	8d e1       	ldi	r24, 0x1D	; 29
 2aa:	91 e0       	ldi	r25, 0x01	; 1
 2ac:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <LcdPuts>
            Display_Number_LCD( recv_cnt, 3 ) ;  // 수신된 바이트수 recv_cnt를 십진수로 변환하여 LCD에 디스플레이
 2b0:	80 91 88 01 	lds	r24, 0x0188
 2b4:	90 e0       	ldi	r25, 0x00	; 0
 2b6:	63 e0       	ldi	r22, 0x03	; 3
 2b8:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <Display_Number_LCD>


		    LcdMove(1,0);    
 2bc:	81 e0       	ldi	r24, 0x01	; 1
 2be:	60 e0       	ldi	r22, 0x00	; 0
 2c0:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
		    LcdPuts("Recv data = "); 
 2c4:	89 e2       	ldi	r24, 0x29	; 41
 2c6:	91 e0       	ldi	r25, 0x01	; 1
 2c8:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <LcdPuts>

		    LcdPutchar( rdata );   // 수신된 문자 LCD에 디스플레이
 2cc:	80 91 87 01 	lds	r24, 0x0187
 2d0:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>

          ////////////////////////////////////////////////////////

		  //////////////  명령어 처리   //////////////

			if( rdata == '0' )          // 문자 0 이 수신되면 
 2d4:	80 91 87 01 	lds	r24, 0x0187
 2d8:	80 33       	cpi	r24, 0x30	; 48
 2da:	11 f4       	brne	.+4      	; 0x2e0 <main+0xa8>
			{
                PORTB |= 0x10 ;          // LED OFF 
 2dc:	c4 9a       	sbi	0x18, 4	; 24
 2de:	55 c0       	rjmp	.+170    	; 0x38a <main+0x152>
			}
			else if( rdata == '1' )     // 문자 1 이 수신되면
 2e0:	80 91 87 01 	lds	r24, 0x0187
 2e4:	81 33       	cpi	r24, 0x31	; 49
 2e6:	11 f4       	brne	.+4      	; 0x2ec <main+0xb4>
			{
                PORTB &= ~0x10 ;         // LED ON
 2e8:	c4 98       	cbi	0x18, 4	; 24
 2ea:	4f c0       	rjmp	.+158    	; 0x38a <main+0x152>
			}
			else if( rdata == '2')      // 문자 2 가 수신되면
 2ec:	80 91 87 01 	lds	r24, 0x0187
 2f0:	82 33       	cpi	r24, 0x32	; 50
 2f2:	69 f5       	brne	.+90     	; 0x34e <main+0x116>
			{

		        HexToDec(recv_cnt,10);   // 수신된 바이트수 recv_cnt 십진수로 변환
 2f4:	80 91 88 01 	lds	r24, 0x0188
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	6a e0       	ldi	r22, 0x0A	; 10
 2fc:	70 e0       	ldi	r23, 0x00	; 0
 2fe:	0e 94 a0 00 	call	0x140	; 0x140 <HexToDec>

                SerialPutString( "Received Data Count = " );     //  메시지 전송 
 302:	86 e3       	ldi	r24, 0x36	; 54
 304:	91 e0       	ldi	r25, 0x01	; 1
 306:	0e 94 96 00 	call	0x12c	; 0x12c <SerialPutString>
//              SerialPutString( Send_Message_1 );               //  메시지 전송 

                SerialPutChar( NumToAsc(cnumber[2]));            //  변수 recv_cnt 값 전송
 30a:	80 91 84 01 	lds	r24, 0x0184


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 30e:	8a 30       	cpi	r24, 0x0A	; 10
 310:	10 f0       	brcs	.+4      	; 0x316 <main+0xde>
 312:	89 5c       	subi	r24, 0xC9	; 201
 314:	01 c0       	rjmp	.+2      	; 0x318 <main+0xe0>
	else	      Num += 0x30;
 316:	80 5d       	subi	r24, 0xD0	; 208
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 318:	5d 9b       	sbis	0x0b, 5	; 11
 31a:	fe cf       	rjmp	.-4      	; 0x318 <main+0xe0>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 31c:	8c b9       	out	0x0c, r24	; 12

                SerialPutString( "Received Data Count = " );     //  메시지 전송 
//              SerialPutString( Send_Message_1 );               //  메시지 전송 

                SerialPutChar( NumToAsc(cnumber[2]));            //  변수 recv_cnt 값 전송
                SerialPutChar( NumToAsc(cnumber[1])); 
 31e:	80 91 83 01 	lds	r24, 0x0183


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 322:	8a 30       	cpi	r24, 0x0A	; 10
 324:	10 f0       	brcs	.+4      	; 0x32a <main+0xf2>
 326:	89 5c       	subi	r24, 0xC9	; 201
 328:	01 c0       	rjmp	.+2      	; 0x32c <main+0xf4>
	else	      Num += 0x30;
 32a:	80 5d       	subi	r24, 0xD0	; 208
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 32c:	5d 9b       	sbis	0x0b, 5	; 11
 32e:	fe cf       	rjmp	.-4      	; 0x32c <main+0xf4>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 330:	8c b9       	out	0x0c, r24	; 12
                SerialPutString( "Received Data Count = " );     //  메시지 전송 
//              SerialPutString( Send_Message_1 );               //  메시지 전송 

                SerialPutChar( NumToAsc(cnumber[2]));            //  변수 recv_cnt 값 전송
                SerialPutChar( NumToAsc(cnumber[1])); 
                SerialPutChar( NumToAsc(cnumber[0])); 
 332:	80 91 82 01 	lds	r24, 0x0182


char NumToAsc(char Num)
{
	
	if( Num > 9 ) Num += 0x37;
 336:	8a 30       	cpi	r24, 0x0A	; 10
 338:	10 f0       	brcs	.+4      	; 0x33e <main+0x106>
 33a:	89 5c       	subi	r24, 0xC9	; 201
 33c:	01 c0       	rjmp	.+2      	; 0x340 <main+0x108>
	else	      Num += 0x30;
 33e:	80 5d       	subi	r24, 0xD0	; 208
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 340:	5d 9b       	sbis	0x0b, 5	; 11
 342:	fe cf       	rjmp	.-4      	; 0x340 <main+0x108>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 344:	8c b9       	out	0x0c, r24	; 12
// 한 문자를 송신한다.
//======================================

void SerialPutChar(char ch)
{
	while(!(UCSR0A & (1<<UDRE)));			// 버퍼가 빌 때를 기다림
 346:	5d 9b       	sbis	0x0b, 5	; 11
 348:	fe cf       	rjmp	.-4      	; 0x346 <main+0x10e>
  	UDR0 = ch;								// 버퍼에 문자를 쓴다
 34a:	1c b9       	out	0x0c, r17	; 12
 34c:	1e c0       	rjmp	.+60     	; 0x38a <main+0x152>
                SerialPutChar( NumToAsc(cnumber[0])); 
                SerialPutChar('\n');                    // 휴대폰으로 데이터 전송시 Line Feed('\n')를 항상 끝에 전송해야함
 
			} 

			else if( rdata != 0xFF)    //  명령 오류 이면
 34e:	80 91 87 01 	lds	r24, 0x0187
 352:	8f 3f       	cpi	r24, 0xFF	; 255
 354:	d1 f0       	breq	.+52     	; 0x38a <main+0x152>
			{

                SerialPutString( "Command Error!!  Try again.\n" ); //  명령 오류 메시지 전송
 356:	8d e4       	ldi	r24, 0x4D	; 77
 358:	91 e0       	ldi	r25, 0x01	; 1
 35a:	0e 94 96 00 	call	0x12c	; 0x12c <SerialPutString>

			    LcdCommand( 0x01) ;       // LCD Claear
 35e:	81 e0       	ldi	r24, 0x01	; 1
 360:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>

			    LcdMove(0, 0 );           // LCD에 오류메시지 디스플레이
 364:	80 e0       	ldi	r24, 0x00	; 0
 366:	60 e0       	ldi	r22, 0x00	; 0
 368:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
		        LcdPuts("Cmd Error!!"); 
 36c:	8a e6       	ldi	r24, 0x6A	; 106
 36e:	91 e0       	ldi	r25, 0x01	; 1
 370:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <LcdPuts>
			    LcdMove(1, 0 );
 374:	81 e0       	ldi	r24, 0x01	; 1
 376:	60 e0       	ldi	r22, 0x00	; 0
 378:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
		        LcdPuts("Try Again."); 
 37c:	86 e7       	ldi	r24, 0x76	; 118
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <LcdPuts>


				Command_Error_Flag = 1;                             // 명령 오류 플래그 셋
 384:	81 e0       	ldi	r24, 0x01	; 1
 386:	80 93 8a 01 	sts	0x018A, r24
			}


     ///////////////////////////////////////////////////////////////

		   if( Command_Error_Flag == 0  )          // 명령에 오류가 없으면  
 38a:	80 91 8a 01 	lds	r24, 0x018A
 38e:	88 23       	and	r24, r24
 390:	89 f4       	brne	.+34     	; 0x3b4 <main+0x17c>
		   {  

	           LcdMove(0, 11); 
 392:	6b e0       	ldi	r22, 0x0B	; 11
 394:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
               Display_Number_LCD( recv_cnt, 3 ) ;  // 수신된 바이트수 recv_cnt를 십진수로 변환하여 LCD에 디스플레이
 398:	80 91 88 01 	lds	r24, 0x0188
 39c:	90 e0       	ldi	r25, 0x00	; 0
 39e:	63 e0       	ldi	r22, 0x03	; 3
 3a0:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <Display_Number_LCD>

		       LcdMove(1,12);    
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	6c e0       	ldi	r22, 0x0C	; 12
 3a8:	0e 94 35 02 	call	0x46a	; 0x46a <LcdMove>
		       LcdPutchar( rdata );                 // 수신된 문자 rdata를 LCD에 디스플레이
 3ac:	80 91 87 01 	lds	r24, 0x0187
 3b0:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>
           }

      ////////////////////////////////////////////////////////////////


		   rdata = 0xFF;                           // 수신된 명령을 초기값으로 리셋
 3b4:	00 93 87 01 	sts	0x0187, r16
           new_recv_flag = 0;                      // 새 문자(명령) 수신 플래그 Reset
 3b8:	10 92 89 01 	sts	0x0189, r1
 3bc:	64 cf       	rjmp	.-312    	; 0x286 <main+0x4e>

000003be <LcdPutchar>:
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 3be:	95 e3       	ldi	r25, 0x35	; 53
 3c0:	29 2f       	mov	r18, r25
 3c2:	2a 95       	dec	r18
 3c4:	f1 f7       	brne	.-4      	; 0x3c2 <LcdPutchar+0x4>
 3c6:	29 2f       	mov	r18, r25
 3c8:	2a 95       	dec	r18
 3ca:	f1 f7       	brne	.-4      	; 0x3c8 <LcdPutchar+0xa>
 3cc:	29 2f       	mov	r18, r25
 3ce:	2a 95       	dec	r18
 3d0:	f1 f7       	brne	.-4      	; 0x3ce <LcdPutchar+0x10>
 3d2:	29 2f       	mov	r18, r25
 3d4:	2a 95       	dec	r18
 3d6:	f1 f7       	brne	.-4      	; 0x3d4 <LcdPutchar+0x16>
 3d8:	9a 95       	dec	r25
 3da:	f1 f7       	brne	.-4      	; 0x3d8 <LcdPutchar+0x1a>
 3dc:	98 2f       	mov	r25, r24
 3de:	90 7f       	andi	r25, 0xF0	; 240
 3e0:	95 60       	ori	r25, 0x05	; 5
 3e2:	95 bb       	out	0x15, r25	; 21
 3e4:	9b 7f       	andi	r25, 0xFB	; 251
 3e6:	95 bb       	out	0x15, r25	; 21
 3e8:	82 95       	swap	r24
 3ea:	80 7f       	andi	r24, 0xF0	; 240
 3ec:	85 60       	ori	r24, 0x05	; 5
 3ee:	85 bb       	out	0x15, r24	; 21
 3f0:	8b 7f       	andi	r24, 0xFB	; 251
 3f2:	85 bb       	out	0x15, r24	; 21
 3f4:	08 95       	ret

000003f6 <LcdPuts>:
 3f6:	cf 93       	push	r28
 3f8:	df 93       	push	r29
 3fa:	ec 01       	movw	r28, r24
 3fc:	03 c0       	rjmp	.+6      	; 0x404 <LcdPuts+0xe>
 3fe:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>
 402:	21 96       	adiw	r28, 0x01	; 1
 404:	88 81       	ld	r24, Y
 406:	88 23       	and	r24, r24
 408:	d1 f7       	brne	.-12     	; 0x3fe <LcdPuts+0x8>
 40a:	df 91       	pop	r29
 40c:	cf 91       	pop	r28
 40e:	08 95       	ret

00000410 <write_command>:
 410:	98 2f       	mov	r25, r24
 412:	90 7f       	andi	r25, 0xF0	; 240
 414:	94 60       	ori	r25, 0x04	; 4
 416:	95 bb       	out	0x15, r25	; 21
 418:	9b 7f       	andi	r25, 0xFB	; 251
 41a:	95 bb       	out	0x15, r25	; 21
 41c:	82 95       	swap	r24
 41e:	80 7f       	andi	r24, 0xF0	; 240
 420:	84 60       	ori	r24, 0x04	; 4
 422:	85 bb       	out	0x15, r24	; 21
 424:	8b 7f       	andi	r24, 0xFB	; 251
 426:	85 bb       	out	0x15, r24	; 21
 428:	85 e0       	ldi	r24, 0x05	; 5
 42a:	8a 95       	dec	r24
 42c:	f1 f7       	brne	.-4      	; 0x42a <write_command+0x1a>
 42e:	08 95       	ret

00000430 <LcdCommand>:
 430:	1f 93       	push	r17
 432:	18 2f       	mov	r17, r24
 434:	85 e3       	ldi	r24, 0x35	; 53
 436:	98 2f       	mov	r25, r24
 438:	9a 95       	dec	r25
 43a:	f1 f7       	brne	.-4      	; 0x438 <LcdCommand+0x8>
 43c:	98 2f       	mov	r25, r24
 43e:	9a 95       	dec	r25
 440:	f1 f7       	brne	.-4      	; 0x43e <LcdCommand+0xe>
 442:	98 2f       	mov	r25, r24
 444:	9a 95       	dec	r25
 446:	f1 f7       	brne	.-4      	; 0x444 <LcdCommand+0x14>
 448:	98 2f       	mov	r25, r24
 44a:	9a 95       	dec	r25
 44c:	f1 f7       	brne	.-4      	; 0x44a <LcdCommand+0x1a>
 44e:	8a 95       	dec	r24
 450:	f1 f7       	brne	.-4      	; 0x44e <LcdCommand+0x1e>
 452:	81 2f       	mov	r24, r17
 454:	0e 94 08 02 	call	0x410	; 0x410 <write_command>
 458:	11 50       	subi	r17, 0x01	; 1
 45a:	12 30       	cpi	r17, 0x02	; 2
 45c:	20 f4       	brcc	.+8      	; 0x466 <LcdCommand+0x36>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 45e:	80 e4       	ldi	r24, 0x40	; 64
 460:	9f e1       	ldi	r25, 0x1F	; 31
 462:	01 97       	sbiw	r24, 0x01	; 1
 464:	f1 f7       	brne	.-4      	; 0x462 <LcdCommand+0x32>
 466:	1f 91       	pop	r17
 468:	08 95       	ret

0000046a <LcdMove>:
 46a:	82 95       	swap	r24
 46c:	88 0f       	add	r24, r24
 46e:	88 0f       	add	r24, r24
 470:	80 7c       	andi	r24, 0xC0	; 192
 472:	68 0f       	add	r22, r24
 474:	86 2f       	mov	r24, r22
 476:	80 68       	ori	r24, 0x80	; 128
 478:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 47c:	08 95       	ret

0000047e <LcdInit>:
 47e:	8f ef       	ldi	r24, 0xFF	; 255
 480:	84 bb       	out	0x14, r24	; 20
 482:	80 e6       	ldi	r24, 0x60	; 96
 484:	9a ee       	ldi	r25, 0xEA	; 234
 486:	01 97       	sbiw	r24, 0x01	; 1
 488:	f1 f7       	brne	.-4      	; 0x486 <LcdInit+0x8>
 48a:	80 e3       	ldi	r24, 0x30	; 48
 48c:	0e 94 08 02 	call	0x410	; 0x410 <write_command>
 490:	80 e2       	ldi	r24, 0x20	; 32
 492:	9e e4       	ldi	r25, 0x4E	; 78
 494:	01 97       	sbiw	r24, 0x01	; 1
 496:	f1 f7       	brne	.-4      	; 0x494 <LcdInit+0x16>
 498:	80 e3       	ldi	r24, 0x30	; 48
 49a:	0e 94 08 02 	call	0x410	; 0x410 <write_command>
 49e:	80 ea       	ldi	r24, 0xA0	; 160
 4a0:	9f e0       	ldi	r25, 0x0F	; 15
 4a2:	01 97       	sbiw	r24, 0x01	; 1
 4a4:	f1 f7       	brne	.-4      	; 0x4a2 <LcdInit+0x24>
 4a6:	82 e3       	ldi	r24, 0x32	; 50
 4a8:	0e 94 08 02 	call	0x410	; 0x410 <write_command>
 4ac:	88 e2       	ldi	r24, 0x28	; 40
 4ae:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 4b2:	88 e0       	ldi	r24, 0x08	; 8
 4b4:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 4b8:	81 e0       	ldi	r24, 0x01	; 1
 4ba:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 4be:	86 e0       	ldi	r24, 0x06	; 6
 4c0:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 4c4:	8c e0       	ldi	r24, 0x0C	; 12
 4c6:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 4ca:	08 95       	ret

000004cc <LcdNewchar>:
 4cc:	0f 93       	push	r16
 4ce:	1f 93       	push	r17
 4d0:	cf 93       	push	r28
 4d2:	df 93       	push	r29
 4d4:	8b 01       	movw	r16, r22
 4d6:	88 0f       	add	r24, r24
 4d8:	88 0f       	add	r24, r24
 4da:	88 0f       	add	r24, r24
 4dc:	80 64       	ori	r24, 0x40	; 64
 4de:	0e 94 18 02 	call	0x430	; 0x430 <LcdCommand>
 4e2:	c0 e0       	ldi	r28, 0x00	; 0
 4e4:	d0 e0       	ldi	r29, 0x00	; 0
 4e6:	f8 01       	movw	r30, r16
 4e8:	ec 0f       	add	r30, r28
 4ea:	fd 1f       	adc	r31, r29
 4ec:	80 81       	ld	r24, Z
 4ee:	0e 94 df 01 	call	0x3be	; 0x3be <LcdPutchar>
 4f2:	21 96       	adiw	r28, 0x01	; 1
 4f4:	c8 30       	cpi	r28, 0x08	; 8
 4f6:	d1 05       	cpc	r29, r1
 4f8:	b1 f7       	brne	.-20     	; 0x4e6 <LcdNewchar+0x1a>
 4fa:	df 91       	pop	r29
 4fc:	cf 91       	pop	r28
 4fe:	1f 91       	pop	r17
 500:	0f 91       	pop	r16
 502:	08 95       	ret

00000504 <__udivmodhi4>:
 504:	aa 1b       	sub	r26, r26
 506:	bb 1b       	sub	r27, r27
 508:	51 e1       	ldi	r21, 0x11	; 17
 50a:	07 c0       	rjmp	.+14     	; 0x51a <__udivmodhi4_ep>

0000050c <__udivmodhi4_loop>:
 50c:	aa 1f       	adc	r26, r26
 50e:	bb 1f       	adc	r27, r27
 510:	a6 17       	cp	r26, r22
 512:	b7 07       	cpc	r27, r23
 514:	10 f0       	brcs	.+4      	; 0x51a <__udivmodhi4_ep>
 516:	a6 1b       	sub	r26, r22
 518:	b7 0b       	sbc	r27, r23

0000051a <__udivmodhi4_ep>:
 51a:	88 1f       	adc	r24, r24
 51c:	99 1f       	adc	r25, r25
 51e:	5a 95       	dec	r21
 520:	a9 f7       	brne	.-22     	; 0x50c <__udivmodhi4_loop>
 522:	80 95       	com	r24
 524:	90 95       	com	r25
 526:	bc 01       	movw	r22, r24
 528:	cd 01       	movw	r24, r26
 52a:	08 95       	ret

0000052c <_exit>:
 52c:	f8 94       	cli

0000052e <__stop_program>:
 52e:	ff cf       	rjmp	.-2      	; 0x52e <__stop_program>
