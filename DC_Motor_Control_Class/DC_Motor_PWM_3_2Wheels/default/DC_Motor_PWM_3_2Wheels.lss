
DC_Motor_PWM_3_2Wheels.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003a  00800100  00000b84  00000c18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b84  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000003a  0080013a  0080013a  00000c52  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000c52  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000001cb  00000000  00000000  00000c92  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000121e  00000000  00000000  00000e5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003be  00000000  00000000  0000207b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c79  00000000  00000000  00002439  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001c0  00000000  00000000  000030b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000003c4  00000000  00000000  00003274  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006c4  00000000  00000000  00003638  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  00003cfc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
   c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  14:	0c 94 de 02 	jmp	0x5bc	; 0x5bc <__vector_5>
  18:	0c 94 4e 03 	jmp	0x69c	; 0x69c <__vector_6>
  1c:	0c 94 bf 03 	jmp	0x77e	; 0x77e <__vector_7>
  20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  40:	0c 94 06 02 	jmp	0x40c	; 0x40c <__vector_16>
  44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
  88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e4 e8       	ldi	r30, 0x84	; 132
  a0:	fb e0       	ldi	r31, 0x0B	; 11
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	aa 33       	cpi	r26, 0x3A	; 58
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	11 e0       	ldi	r17, 0x01	; 1
  b4:	aa e3       	ldi	r26, 0x3A	; 58
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a4 37       	cpi	r26, 0x74	; 116
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0e 94 cb 04 	call	0x996	; 0x996 <main>
  c6:	0c 94 c0 05 	jmp	0xb80	; 0xb80 <_exit>

000000ca <__bad_interrupt>:
  ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <LcdPutchar>:
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  ce:	95 e3       	ldi	r25, 0x35	; 53
  d0:	29 2f       	mov	r18, r25
  d2:	2a 95       	dec	r18
  d4:	f1 f7       	brne	.-4      	; 0xd2 <LcdPutchar+0x4>

static void write_data(char ch)
{
	unsigned char temp;

	temp = (ch & 0xF0) | 0x05;
  d6:	29 2f       	mov	r18, r25
  d8:	2a 95       	dec	r18
  da:	f1 f7       	brne	.-4      	; 0xd8 <LcdPutchar+0xa>
  dc:	29 2f       	mov	r18, r25
  de:	2a 95       	dec	r18
  e0:	f1 f7       	brne	.-4      	; 0xde <LcdPutchar+0x10>
  e2:	29 2f       	mov	r18, r25
  e4:	2a 95       	dec	r18
  e6:	f1 f7       	brne	.-4      	; 0xe4 <LcdPutchar+0x16>
  e8:	9a 95       	dec	r25
  ea:	f1 f7       	brne	.-4      	; 0xe8 <LcdPutchar+0x1a>
  ec:	98 2f       	mov	r25, r24
  ee:	90 7f       	andi	r25, 0xF0	; 240
  f0:	95 60       	ori	r25, 0x05	; 5

	LCD_PORT = temp;
  f2:	95 bb       	out	0x15, r25	; 21
	LCD_PORT = temp & ~0x04;
  f4:	9b 7f       	andi	r25, 0xFB	; 251
  f6:	95 bb       	out	0x15, r25	; 21

	temp = (ch<<4) | 0x05;
  f8:	82 95       	swap	r24
  fa:	80 7f       	andi	r24, 0xF0	; 240
  fc:	85 60       	ori	r24, 0x05	; 5

	LCD_PORT = temp;
  fe:	85 bb       	out	0x15, r24	; 21
	LCD_PORT = temp & ~0x04;
 100:	8b 7f       	andi	r24, 0xFB	; 251
 102:	85 bb       	out	0x15, r24	; 21

void LcdPutchar(char ch)
{
	checkbusy();
	write_data(ch);
}
 104:	08 95       	ret

00000106 <LcdPuts>:

void LcdPuts(char* str)
{
 106:	cf 93       	push	r28
 108:	df 93       	push	r29
 10a:	ec 01       	movw	r28, r24
 10c:	03 c0       	rjmp	.+6      	; 0x114 <LcdPuts+0xe>
   while(*str)
  {
   LcdPutchar(*str);
 10e:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>
   str++;
 112:	21 96       	adiw	r28, 0x01	; 1
	write_data(ch);
}

void LcdPuts(char* str)
{
   while(*str)
 114:	88 81       	ld	r24, Y
 116:	88 23       	and	r24, r24
 118:	d1 f7       	brne	.-12     	; 0x10e <LcdPuts+0x8>
  {
   LcdPutchar(*str);
   str++;
  }
}
 11a:	df 91       	pop	r29
 11c:	cf 91       	pop	r28
 11e:	08 95       	ret

00000120 <write_command>:

static void write_command(char command)

{
  char temp;
  temp = (command & 0xF0)|0x04;
 120:	98 2f       	mov	r25, r24
 122:	90 7f       	andi	r25, 0xF0	; 240
 124:	94 60       	ori	r25, 0x04	; 4

LCD_PORT = temp;
 126:	95 bb       	out	0x15, r25	; 21
LCD_PORT = temp & ~0x04;
 128:	9b 7f       	andi	r25, 0xFB	; 251
 12a:	95 bb       	out	0x15, r25	; 21

temp = (command << 4) | 0x04;
 12c:	82 95       	swap	r24
 12e:	80 7f       	andi	r24, 0xF0	; 240
 130:	84 60       	ori	r24, 0x04	; 4

LCD_PORT = temp;
 132:	85 bb       	out	0x15, r24	; 21
LCD_PORT = temp & ~0x04;
 134:	8b 7f       	andi	r24, 0xFB	; 251
 136:	85 bb       	out	0x15, r24	; 21
 138:	85 e0       	ldi	r24, 0x05	; 5
 13a:	8a 95       	dec	r24
 13c:	f1 f7       	brne	.-4      	; 0x13a <write_command+0x1a>
_delay_us(1);
}
 13e:	08 95       	ret

00000140 <LcdCommand>:
	LcdCommand(ENTMOD);

	LcdCommand(DISP_ON);
}
void LcdCommand(char command)
{
 140:	1f 93       	push	r17
 142:	18 2f       	mov	r17, r24
 144:	85 e3       	ldi	r24, 0x35	; 53
 146:	98 2f       	mov	r25, r24
 148:	9a 95       	dec	r25
 14a:	f1 f7       	brne	.-4      	; 0x148 <LcdCommand+0x8>
	checkbusy();
	write_command(command);
 14c:	98 2f       	mov	r25, r24
 14e:	9a 95       	dec	r25
 150:	f1 f7       	brne	.-4      	; 0x14e <LcdCommand+0xe>
 152:	98 2f       	mov	r25, r24
 154:	9a 95       	dec	r25
 156:	f1 f7       	brne	.-4      	; 0x154 <LcdCommand+0x14>
 158:	98 2f       	mov	r25, r24
 15a:	9a 95       	dec	r25
 15c:	f1 f7       	brne	.-4      	; 0x15a <LcdCommand+0x1a>
 15e:	8a 95       	dec	r24
 160:	f1 f7       	brne	.-4      	; 0x15e <LcdCommand+0x1e>
 162:	81 2f       	mov	r24, r17
 164:	0e 94 90 00 	call	0x120	; 0x120 <write_command>
	if(command==ALLCLR || command==HOME)
 168:	11 50       	subi	r17, 0x01	; 1
 16a:	12 30       	cpi	r17, 0x02	; 2
 16c:	20 f4       	brcc	.+8      	; 0x176 <LcdCommand+0x36>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 16e:	80 e4       	ldi	r24, 0x40	; 64
 170:	9f e1       	ldi	r25, 0x1F	; 31
 172:	01 97       	sbiw	r24, 0x01	; 1
 174:	f1 f7       	brne	.-4      	; 0x172 <LcdCommand+0x32>
		_delay_ms(2);
}
 176:	1f 91       	pop	r17
 178:	08 95       	ret

0000017a <LcdNewchar>:
  LcdCommand(pos);
}


void LcdNewchar(char ch, char font[])
{
 17a:	0f 93       	push	r16
 17c:	1f 93       	push	r17
 17e:	cf 93       	push	r28
 180:	df 93       	push	r29
 182:	8b 01       	movw	r16, r22
 int i;

 ch <<=3;
 184:	88 0f       	add	r24, r24
 186:	88 0f       	add	r24, r24
 188:	88 0f       	add	r24, r24
 ch|= 0x40;

 LcdCommand(ch);
 18a:	80 64       	ori	r24, 0x40	; 64
 18c:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
 190:	c0 e0       	ldi	r28, 0x00	; 0
 192:	d0 e0       	ldi	r29, 0x00	; 0

 for(i=0;i<8;i++)
    LcdPutchar(font[i]);
 194:	f8 01       	movw	r30, r16
 196:	ec 0f       	add	r30, r28
 198:	fd 1f       	adc	r31, r29
 19a:	80 81       	ld	r24, Z
 19c:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>
 ch <<=3;
 ch|= 0x40;

 LcdCommand(ch);

 for(i=0;i<8;i++)
 1a0:	21 96       	adiw	r28, 0x01	; 1
 1a2:	c8 30       	cpi	r28, 0x08	; 8
 1a4:	d1 05       	cpc	r29, r1
 1a6:	b1 f7       	brne	.-20     	; 0x194 <LcdNewchar+0x1a>
    LcdPutchar(font[i]);
}
 1a8:	df 91       	pop	r29
 1aa:	cf 91       	pop	r28
 1ac:	1f 91       	pop	r17
 1ae:	0f 91       	pop	r16
 1b0:	08 95       	ret

000001b2 <LcdMove>:

{ 

//  pos = (line << 6) + pos; 

	if(line == 0 )       pos = 0x00 + pos ;
 1b2:	88 23       	and	r24, r24
 1b4:	49 f0       	breq	.+18     	; 0x1c8 <LcdMove+0x16>
	else if( line == 1 ) pos = 0x40 + pos ;
 1b6:	81 30       	cpi	r24, 0x01	; 1
 1b8:	11 f4       	brne	.+4      	; 0x1be <LcdMove+0xc>
 1ba:	60 5c       	subi	r22, 0xC0	; 192
 1bc:	05 c0       	rjmp	.+10     	; 0x1c8 <LcdMove+0x16>
	else if( line == 2 ) pos = 0x10 + pos ;
 1be:	82 30       	cpi	r24, 0x02	; 2
 1c0:	11 f4       	brne	.+4      	; 0x1c6 <LcdMove+0x14>
 1c2:	60 5f       	subi	r22, 0xF0	; 240
 1c4:	01 c0       	rjmp	.+2      	; 0x1c8 <LcdMove+0x16>
	else                 pos = 0x50 + pos ;
 1c6:	60 5b       	subi	r22, 0xB0	; 176

  pos |= 0x80;
 
  LcdCommand(pos);
 1c8:	86 2f       	mov	r24, r22
 1ca:	80 68       	ori	r24, 0x80	; 128
 1cc:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
}
 1d0:	08 95       	ret

000001d2 <LcdInit>:
static void write_command(char command);
static void write_data(char ch);

void LcdInit(void)
{
	LCD_DDR = 0xff;
 1d2:	8f ef       	ldi	r24, 0xFF	; 255
 1d4:	84 bb       	out	0x14, r24	; 20
 1d6:	80 e6       	ldi	r24, 0x60	; 96
 1d8:	9a ee       	ldi	r25, 0xEA	; 234
 1da:	01 97       	sbiw	r24, 0x01	; 1
 1dc:	f1 f7       	brne	.-4      	; 0x1da <LcdInit+0x8>
	_delay_ms(15);
	write_command(0x30);
 1de:	80 e3       	ldi	r24, 0x30	; 48
 1e0:	0e 94 90 00 	call	0x120	; 0x120 <write_command>
 1e4:	80 e2       	ldi	r24, 0x20	; 32
 1e6:	9e e4       	ldi	r25, 0x4E	; 78
 1e8:	01 97       	sbiw	r24, 0x01	; 1
 1ea:	f1 f7       	brne	.-4      	; 0x1e8 <LcdInit+0x16>
	_delay_ms(5);
	write_command(0x30);
 1ec:	80 e3       	ldi	r24, 0x30	; 48
 1ee:	0e 94 90 00 	call	0x120	; 0x120 <write_command>
 1f2:	80 ea       	ldi	r24, 0xA0	; 160
 1f4:	9f e0       	ldi	r25, 0x0F	; 15
 1f6:	01 97       	sbiw	r24, 0x01	; 1
 1f8:	f1 f7       	brne	.-4      	; 0x1f6 <LcdInit+0x24>
	_delay_ms(1);
	write_command(0x32);
 1fa:	82 e3       	ldi	r24, 0x32	; 50
 1fc:	0e 94 90 00 	call	0x120	; 0x120 <write_command>

	LcdCommand(FUNSET);
 200:	88 e2       	ldi	r24, 0x28	; 40
 202:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
	LcdCommand(DISP_OFF);
 206:	88 e0       	ldi	r24, 0x08	; 8
 208:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
	LcdCommand(ALLCLR);
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
	LcdCommand(ENTMOD);
 212:	86 e0       	ldi	r24, 0x06	; 6
 214:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>

	LcdCommand(DISP_ON);
 218:	8c e0       	ldi	r24, 0x0C	; 12
 21a:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
}
 21e:	08 95       	ret

00000220 <DC_Motor_Run_Fwd_L>:
///////////////////////////////////////////////////////////////////////



void DC_Motor_Run_Fwd_L( short duty )   // DC 모터 정회전 함수 
{
 220:	9c 01       	movw	r18, r24

    if( duty > Vmax_L )     duty = Vmax_L ;
 222:	80 91 70 01 	lds	r24, 0x0170
 226:	90 91 71 01 	lds	r25, 0x0171
 22a:	82 17       	cp	r24, r18
 22c:	93 07       	cpc	r25, r19
 22e:	24 f4       	brge	.+8      	; 0x238 <DC_Motor_Run_Fwd_L+0x18>
 230:	20 91 70 01 	lds	r18, 0x0170
 234:	30 91 71 01 	lds	r19, 0x0171

    PORTA &= ~0x01;     //  왼쪽 모터 구동신호 - 단자 : 0 V 인가( PA0 = 0 );  
 238:	d8 98       	cbi	0x1b, 0	; 27
	OCR1A = duty;       //  왼쪽 모터 구동신호 + 단자 : OC1A(PB5) PWM duty 설정 
 23a:	3b bd       	out	0x2b, r19	; 43
 23c:	2a bd       	out	0x2a, r18	; 42

}
 23e:	08 95       	ret

00000240 <DC_Motor_Run_Rev_L>:

void DC_Motor_Run_Rev_L( short duty )   // DC 모터 역회전 함수 
{
 240:	9c 01       	movw	r18, r24

    if( duty > Vmax_L )     duty = Vmax_L ;
 242:	80 91 70 01 	lds	r24, 0x0170
 246:	90 91 71 01 	lds	r25, 0x0171
 24a:	82 17       	cp	r24, r18
 24c:	93 07       	cpc	r25, r19
 24e:	24 f4       	brge	.+8      	; 0x258 <DC_Motor_Run_Rev_L+0x18>
 250:	20 91 70 01 	lds	r18, 0x0170
 254:	30 91 71 01 	lds	r19, 0x0171

    PORTA |= 0x01;              //  왼쪽 모터 구동신호 - 단자 : 5 V 인가( PA0 = 1 );  
 258:	d8 9a       	sbi	0x1b, 0	; 27
	OCR1A = Vmax_L - duty;      //  왼쪽 모터 구동신호 + 단자 : OC1A(PB5) PWM duty 설정 
 25a:	80 91 70 01 	lds	r24, 0x0170
 25e:	90 91 71 01 	lds	r25, 0x0171
 262:	82 1b       	sub	r24, r18
 264:	93 0b       	sbc	r25, r19
 266:	9b bd       	out	0x2b, r25	; 43
 268:	8a bd       	out	0x2a, r24	; 42

}
 26a:	08 95       	ret

0000026c <DC_Motor_Stop_L>:


void DC_Motor_Stop_L( void )   // 왼쪽 DC 모터 정지 함수 
{

    PORTA &= ~0x01;     //  왼쪽 모터 구동신호 - 단자 : 0 V 인가( PA0 = 0 );  
 26c:	d8 98       	cbi	0x1b, 0	; 27
	OCR1A = 0;          //  왼쪽 모터 구동신호 + 단자 : OC1A(PB5) PWM duty = 0 설정 
 26e:	1b bc       	out	0x2b, r1	; 43
 270:	1a bc       	out	0x2a, r1	; 42

}
 272:	08 95       	ret

00000274 <DC_Motor_Run_Fwd_R>:



void DC_Motor_Run_Fwd_R( short duty )   // 오른쪽 DC 모터 정회전 함수 
{
 274:	9c 01       	movw	r18, r24

    if( duty > Vmax_R )     duty = Vmax_R ;
 276:	80 91 6e 01 	lds	r24, 0x016E
 27a:	90 91 6f 01 	lds	r25, 0x016F
 27e:	82 17       	cp	r24, r18
 280:	93 07       	cpc	r25, r19
 282:	24 f4       	brge	.+8      	; 0x28c <DC_Motor_Run_Fwd_R+0x18>
 284:	20 91 6e 01 	lds	r18, 0x016E
 288:	30 91 6f 01 	lds	r19, 0x016F

    PORTA &= ~0x02;     //  오른쪽 모터 구동신호 - 단자 : 0 V 인가( PA1 = 0 );  
 28c:	d9 98       	cbi	0x1b, 1	; 27
	OCR1B = duty;       //  오른쪽 모터 구동신호 + 단자 : OC1B(PB6) PWM duty 설정 
 28e:	39 bd       	out	0x29, r19	; 41
 290:	28 bd       	out	0x28, r18	; 40

}
 292:	08 95       	ret

00000294 <DC_Motor_Run_Rev_R>:

void DC_Motor_Run_Rev_R( short duty )   // 오른쪽 DC 모터 역회전 함수 
{
 294:	9c 01       	movw	r18, r24

    if( duty > Vmax_R )     duty = Vmax_R ;
 296:	80 91 6e 01 	lds	r24, 0x016E
 29a:	90 91 6f 01 	lds	r25, 0x016F
 29e:	82 17       	cp	r24, r18
 2a0:	93 07       	cpc	r25, r19
 2a2:	24 f4       	brge	.+8      	; 0x2ac <DC_Motor_Run_Rev_R+0x18>
 2a4:	20 91 6e 01 	lds	r18, 0x016E
 2a8:	30 91 6f 01 	lds	r19, 0x016F

    PORTA |= 0x02;                //  오른쪽 모터 구동신호 - 단자 : 5 V 인가( PA1 = 1 );  
 2ac:	d9 9a       	sbi	0x1b, 1	; 27
	OCR1B = Vmax_R - duty ;       //  오른쪽 모터 구동신호 + 단자 : OC1B(PB6) PWM duty 설정 
 2ae:	80 91 6e 01 	lds	r24, 0x016E
 2b2:	90 91 6f 01 	lds	r25, 0x016F
 2b6:	82 1b       	sub	r24, r18
 2b8:	93 0b       	sbc	r25, r19
 2ba:	99 bd       	out	0x29, r25	; 41
 2bc:	88 bd       	out	0x28, r24	; 40

}
 2be:	08 95       	ret

000002c0 <DC_Motor_Stop_R>:


void DC_Motor_Stop_R( void )   // 오른쪽 DC 모터 정지 함수 
{

    PORTA &= ~0x02;     //  오른쪽 모터 구동신호 - 단자 : 0 V 인가( PA1 = 0 );  
 2c0:	d9 98       	cbi	0x1b, 1	; 27
	OCR1B = 0;          //  오른쪽 모터 구동신호 + 단자 : OC1B(PB6) PWM duty = 0 설정 
 2c2:	19 bc       	out	0x29, r1	; 41
 2c4:	18 bc       	out	0x28, r1	; 40

}
 2c6:	08 95       	ret

000002c8 <DC_Motor_PWM_L>:


void DC_Motor_PWM_L( short Vref )   // 왼쪽 DC 모터 PWM 신호 발생 함수  
{
 2c8:	9c 01       	movw	r18, r24

   if ( Vref > Vmax_L )       Vref = Vmax_L ;
 2ca:	80 91 70 01 	lds	r24, 0x0170
 2ce:	90 91 71 01 	lds	r25, 0x0171
 2d2:	82 17       	cp	r24, r18
 2d4:	93 07       	cpc	r25, r19
 2d6:	2c f4       	brge	.+10     	; 0x2e2 <DC_Motor_PWM_L+0x1a>
 2d8:	20 91 70 01 	lds	r18, 0x0170
 2dc:	30 91 71 01 	lds	r19, 0x0171
 2e0:	12 c0       	rjmp	.+36     	; 0x306 <DC_Motor_PWM_L+0x3e>
   else if( Vref < -Vmax_L )  Vref = -Vmax_L ;
 2e2:	80 91 70 01 	lds	r24, 0x0170
 2e6:	90 91 71 01 	lds	r25, 0x0171
 2ea:	90 95       	com	r25
 2ec:	81 95       	neg	r24
 2ee:	9f 4f       	sbci	r25, 0xFF	; 255
 2f0:	28 17       	cp	r18, r24
 2f2:	39 07       	cpc	r19, r25
 2f4:	44 f4       	brge	.+16     	; 0x306 <DC_Motor_PWM_L+0x3e>
 2f6:	80 91 70 01 	lds	r24, 0x0170
 2fa:	90 91 71 01 	lds	r25, 0x0171
 2fe:	22 27       	eor	r18, r18
 300:	33 27       	eor	r19, r19
 302:	28 1b       	sub	r18, r24
 304:	39 0b       	sbc	r19, r25

   if( Vref > 0 )  
 306:	12 16       	cp	r1, r18
 308:	13 06       	cpc	r1, r19
 30a:	7c f4       	brge	.+30     	; 0x32a <DC_Motor_PWM_L+0x62>


void DC_Motor_Run_Fwd_L( short duty )   // DC 모터 정회전 함수 
{

    if( duty > Vmax_L )     duty = Vmax_L ;
 30c:	80 91 70 01 	lds	r24, 0x0170
 310:	90 91 71 01 	lds	r25, 0x0171
 314:	82 17       	cp	r24, r18
 316:	93 07       	cpc	r25, r19
 318:	24 f4       	brge	.+8      	; 0x322 <DC_Motor_PWM_L+0x5a>
 31a:	20 91 70 01 	lds	r18, 0x0170
 31e:	30 91 71 01 	lds	r19, 0x0171

    PORTA &= ~0x01;     //  왼쪽 모터 구동신호 - 단자 : 0 V 인가( PA0 = 0 );  
 322:	d8 98       	cbi	0x1b, 0	; 27
	OCR1A = duty;       //  왼쪽 모터 구동신호 + 단자 : OC1A(PB5) PWM duty 설정 
 324:	3b bd       	out	0x2b, r19	; 43
 326:	2a bd       	out	0x2a, r18	; 42
 328:	08 95       	ret

   if( Vref > 0 )  
   {
      DC_Motor_Run_Fwd_L( Vref ) ;
   }
   else if( Vref == 0 )  
 32a:	21 15       	cp	r18, r1
 32c:	31 05       	cpc	r19, r1
 32e:	21 f4       	brne	.+8      	; 0x338 <DC_Motor_PWM_L+0x70>


void DC_Motor_Stop_L( void )   // 왼쪽 DC 모터 정지 함수 
{

    PORTA &= ~0x01;     //  왼쪽 모터 구동신호 - 단자 : 0 V 인가( PA0 = 0 );  
 330:	d8 98       	cbi	0x1b, 0	; 27
	OCR1A = 0;          //  왼쪽 모터 구동신호 + 단자 : OC1A(PB5) PWM duty = 0 설정 
 332:	1b bc       	out	0x2b, r1	; 43
 334:	1a bc       	out	0x2a, r1	; 42
 336:	08 95       	ret
   {
      DC_Motor_Stop_L() ;
   }
   else if( Vref < 0 )  
   {
      DC_Motor_Run_Rev_L( -Vref ) ;
 338:	44 27       	eor	r20, r20
 33a:	55 27       	eor	r21, r21
 33c:	42 1b       	sub	r20, r18
 33e:	53 0b       	sbc	r21, r19
}

void DC_Motor_Run_Rev_L( short duty )   // DC 모터 역회전 함수 
{

    if( duty > Vmax_L )     duty = Vmax_L ;
 340:	80 91 70 01 	lds	r24, 0x0170
 344:	90 91 71 01 	lds	r25, 0x0171
 348:	84 17       	cp	r24, r20
 34a:	95 07       	cpc	r25, r21
 34c:	24 f4       	brge	.+8      	; 0x356 <DC_Motor_PWM_L+0x8e>
 34e:	40 91 70 01 	lds	r20, 0x0170
 352:	50 91 71 01 	lds	r21, 0x0171

    PORTA |= 0x01;              //  왼쪽 모터 구동신호 - 단자 : 5 V 인가( PA0 = 1 );  
 356:	d8 9a       	sbi	0x1b, 0	; 27
	OCR1A = Vmax_L - duty;      //  왼쪽 모터 구동신호 + 단자 : OC1A(PB5) PWM duty 설정 
 358:	80 91 70 01 	lds	r24, 0x0170
 35c:	90 91 71 01 	lds	r25, 0x0171
 360:	84 1b       	sub	r24, r20
 362:	95 0b       	sbc	r25, r21
 364:	9b bd       	out	0x2b, r25	; 43
 366:	8a bd       	out	0x2a, r24	; 42
 368:	08 95       	ret

0000036a <DC_Motor_PWM_R>:

}


void DC_Motor_PWM_R( short Vref )   // 오른쪽 DC 모터 PWM 신호 발생 함수  
{
 36a:	9c 01       	movw	r18, r24

   if ( Vref > Vmax_R )       Vref = Vmax_R ;
 36c:	80 91 6e 01 	lds	r24, 0x016E
 370:	90 91 6f 01 	lds	r25, 0x016F
 374:	82 17       	cp	r24, r18
 376:	93 07       	cpc	r25, r19
 378:	2c f4       	brge	.+10     	; 0x384 <DC_Motor_PWM_R+0x1a>
 37a:	20 91 6e 01 	lds	r18, 0x016E
 37e:	30 91 6f 01 	lds	r19, 0x016F
 382:	12 c0       	rjmp	.+36     	; 0x3a8 <DC_Motor_PWM_R+0x3e>
   else if( Vref < -Vmax_R )  Vref = -Vmax_R ;
 384:	80 91 6e 01 	lds	r24, 0x016E
 388:	90 91 6f 01 	lds	r25, 0x016F
 38c:	90 95       	com	r25
 38e:	81 95       	neg	r24
 390:	9f 4f       	sbci	r25, 0xFF	; 255
 392:	28 17       	cp	r18, r24
 394:	39 07       	cpc	r19, r25
 396:	44 f4       	brge	.+16     	; 0x3a8 <DC_Motor_PWM_R+0x3e>
 398:	80 91 6e 01 	lds	r24, 0x016E
 39c:	90 91 6f 01 	lds	r25, 0x016F
 3a0:	22 27       	eor	r18, r18
 3a2:	33 27       	eor	r19, r19
 3a4:	28 1b       	sub	r18, r24
 3a6:	39 0b       	sbc	r19, r25

   if( Vref > 0 )  
 3a8:	12 16       	cp	r1, r18
 3aa:	13 06       	cpc	r1, r19
 3ac:	7c f4       	brge	.+30     	; 0x3cc <DC_Motor_PWM_R+0x62>


void DC_Motor_Run_Fwd_R( short duty )   // 오른쪽 DC 모터 정회전 함수 
{

    if( duty > Vmax_R )     duty = Vmax_R ;
 3ae:	80 91 6e 01 	lds	r24, 0x016E
 3b2:	90 91 6f 01 	lds	r25, 0x016F
 3b6:	82 17       	cp	r24, r18
 3b8:	93 07       	cpc	r25, r19
 3ba:	24 f4       	brge	.+8      	; 0x3c4 <DC_Motor_PWM_R+0x5a>
 3bc:	20 91 6e 01 	lds	r18, 0x016E
 3c0:	30 91 6f 01 	lds	r19, 0x016F

    PORTA &= ~0x02;     //  오른쪽 모터 구동신호 - 단자 : 0 V 인가( PA1 = 0 );  
 3c4:	d9 98       	cbi	0x1b, 1	; 27
	OCR1B = duty;       //  오른쪽 모터 구동신호 + 단자 : OC1B(PB6) PWM duty 설정 
 3c6:	39 bd       	out	0x29, r19	; 41
 3c8:	28 bd       	out	0x28, r18	; 40
 3ca:	08 95       	ret

   if( Vref > 0 )  
   {
      DC_Motor_Run_Fwd_R( Vref ) ;
   }
   else if( Vref == 0 )  
 3cc:	21 15       	cp	r18, r1
 3ce:	31 05       	cpc	r19, r1
 3d0:	21 f4       	brne	.+8      	; 0x3da <DC_Motor_PWM_R+0x70>


void DC_Motor_Stop_R( void )   // 오른쪽 DC 모터 정지 함수 
{

    PORTA &= ~0x02;     //  오른쪽 모터 구동신호 - 단자 : 0 V 인가( PA1 = 0 );  
 3d2:	d9 98       	cbi	0x1b, 1	; 27
	OCR1B = 0;          //  오른쪽 모터 구동신호 + 단자 : OC1B(PB6) PWM duty = 0 설정 
 3d4:	19 bc       	out	0x29, r1	; 41
 3d6:	18 bc       	out	0x28, r1	; 40
 3d8:	08 95       	ret
   {
      DC_Motor_Stop_R() ;
   }
   else if( Vref < 0 )  
   {
      DC_Motor_Run_Rev_R( -Vref ) ;
 3da:	44 27       	eor	r20, r20
 3dc:	55 27       	eor	r21, r21
 3de:	42 1b       	sub	r20, r18
 3e0:	53 0b       	sbc	r21, r19
}

void DC_Motor_Run_Rev_R( short duty )   // 오른쪽 DC 모터 역회전 함수 
{

    if( duty > Vmax_R )     duty = Vmax_R ;
 3e2:	80 91 6e 01 	lds	r24, 0x016E
 3e6:	90 91 6f 01 	lds	r25, 0x016F
 3ea:	84 17       	cp	r24, r20
 3ec:	95 07       	cpc	r25, r21
 3ee:	24 f4       	brge	.+8      	; 0x3f8 <DC_Motor_PWM_R+0x8e>
 3f0:	40 91 6e 01 	lds	r20, 0x016E
 3f4:	50 91 6f 01 	lds	r21, 0x016F

    PORTA |= 0x02;                //  오른쪽 모터 구동신호 - 단자 : 5 V 인가( PA1 = 1 );  
 3f8:	d9 9a       	sbi	0x1b, 1	; 27
	OCR1B = Vmax_R - duty ;       //  오른쪽 모터 구동신호 + 단자 : OC1B(PB6) PWM duty 설정 
 3fa:	80 91 6e 01 	lds	r24, 0x016E
 3fe:	90 91 6f 01 	lds	r25, 0x016F
 402:	84 1b       	sub	r24, r20
 404:	95 0b       	sbc	r25, r21
 406:	99 bd       	out	0x29, r25	; 41
 408:	88 bd       	out	0x28, r24	; 40
 40a:	08 95       	ret

0000040c <__vector_16>:

//////////////////////////////////////////////////////////////////////////////


ISR( TIMER0_OVF_vect )    //  10 msec 주기 타이머1 오버플로 인터럽트 서비스프로그램
{
 40c:	1f 92       	push	r1
 40e:	0f 92       	push	r0
 410:	0f b6       	in	r0, 0x3f	; 63
 412:	0f 92       	push	r0
 414:	11 24       	eor	r1, r1
 416:	2f 93       	push	r18
 418:	3f 93       	push	r19
 41a:	5f 93       	push	r21
 41c:	6f 93       	push	r22
 41e:	7f 93       	push	r23
 420:	8f 93       	push	r24
 422:	9f 93       	push	r25
 424:	af 93       	push	r26
 426:	bf 93       	push	r27

    static unsigned short  time_index = 0 ; 


    TCNT0 = 256 - 156;       //  내부클럭주기 = 1024/ (16x10^6) = 64 usec,  
 428:	84 e6       	ldi	r24, 0x64	; 100
 42a:	82 bf       	out	0x32, r24	; 50
                             //  오버플로인터럽트 주기 = 10msec
                             //  156 = 10msec/ 64usec


    time_index++ ; 
 42c:	80 91 6c 01 	lds	r24, 0x016C
 430:	90 91 6d 01 	lds	r25, 0x016D
 434:	01 96       	adiw	r24, 0x01	; 1
 436:	90 93 6d 01 	sts	0x016D, r25
 43a:	80 93 6c 01 	sts	0x016C, r24


    if( time_index == 5 )   // 50 msec 주기 
 43e:	05 97       	sbiw	r24, 0x05	; 5
 440:	09 f0       	breq	.+2      	; 0x444 <__vector_16+0x38>
 442:	ae c0       	rjmp	.+348    	; 0x5a0 <__vector_16+0x194>
    {

       time_index = 0; 
 444:	10 92 6d 01 	sts	0x016D, r1
 448:	10 92 6c 01 	sts	0x016C, r1

       sensor_count++;          // 초음파 센서 카운터 값 증가 
 44c:	80 91 67 01 	lds	r24, 0x0167
 450:	90 91 68 01 	lds	r25, 0x0168
 454:	01 96       	adiw	r24, 0x01	; 1
 456:	90 93 68 01 	sts	0x0168, r25
 45a:	80 93 67 01 	sts	0x0167, r24
	       
	   if( sensor_count == 4 )  sensor_count = 1; 
 45e:	80 91 67 01 	lds	r24, 0x0167
 462:	90 91 68 01 	lds	r25, 0x0168
 466:	04 97       	sbiw	r24, 0x04	; 4
 468:	31 f4       	brne	.+12     	; 0x476 <__vector_16+0x6a>
 46a:	81 e0       	ldi	r24, 0x01	; 1
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	90 93 68 01 	sts	0x0168, r25
 472:	80 93 67 01 	sts	0x0167, r24


       if ( sensor_count == 1 )        //  초음파센서 1 트리거 신호 발생(초음파 1 발사) 
 476:	80 91 67 01 	lds	r24, 0x0167
 47a:	90 91 68 01 	lds	r25, 0x0168
 47e:	01 97       	sbiw	r24, 0x01	; 1
 480:	69 f4       	brne	.+26     	; 0x49c <__vector_16+0x90>
	   {
	      PORTB |= 0x01;    // PB0 : High
 482:	c0 9a       	sbi	0x18, 0	; 24
 484:	84 e1       	ldi	r24, 0x14	; 20
 486:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 488:	35 e0       	ldi	r19, 0x05	; 5
 48a:	23 2f       	mov	r18, r19
 48c:	2a 95       	dec	r18
 48e:	f1 f7       	brne	.-4      	; 0x48c <__vector_16+0x80>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 490:	01 97       	sbiw	r24, 0x01	; 1
 492:	d9 f7       	brne	.-10     	; 0x48a <__vector_16+0x7e>

       if ( sensor_count == 1 )        //  초음파센서 1 트리거 신호 발생(초음파 1 발사) 
	   {
	      PORTB |= 0x01;    // PB0 : High
		  usec_delay(20) ;  // 20usec 동안 High 유지 
	      PORTB &= ~0x01;   // PB0 : Low 
 494:	c0 98       	cbi	0x18, 0	; 24
          
		  active_sensor_flag = 1;
 496:	81 e0       	ldi	r24, 0x01	; 1
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	25 c0       	rjmp	.+74     	; 0x4e6 <__vector_16+0xda>

	   }
       else if ( sensor_count == 2 )   //  초음파센서 2 트리거 신호 발생(초음파 2 발사)
 49c:	80 91 67 01 	lds	r24, 0x0167
 4a0:	90 91 68 01 	lds	r25, 0x0168
 4a4:	02 97       	sbiw	r24, 0x02	; 2
 4a6:	69 f4       	brne	.+26     	; 0x4c2 <__vector_16+0xb6>
	   {
	      PORTB |= 0x02;    // PB1 : High
 4a8:	c1 9a       	sbi	0x18, 1	; 24
 4aa:	84 e1       	ldi	r24, 0x14	; 20
 4ac:	90 e0       	ldi	r25, 0x00	; 0
 4ae:	35 e0       	ldi	r19, 0x05	; 5
 4b0:	23 2f       	mov	r18, r19
 4b2:	2a 95       	dec	r18
 4b4:	f1 f7       	brne	.-4      	; 0x4b2 <__vector_16+0xa6>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 4b6:	01 97       	sbiw	r24, 0x01	; 1
 4b8:	d9 f7       	brne	.-10     	; 0x4b0 <__vector_16+0xa4>
	   }
       else if ( sensor_count == 2 )   //  초음파센서 2 트리거 신호 발생(초음파 2 발사)
	   {
	      PORTB |= 0x02;    // PB1 : High
	 	  usec_delay(20) ;  // 20usec 동안 High 유지 
	      PORTB &= ~0x02;   // PB1 : Low 
 4ba:	c1 98       	cbi	0x18, 1	; 24

		  active_sensor_flag = 2;
 4bc:	82 e0       	ldi	r24, 0x02	; 2
 4be:	90 e0       	ldi	r25, 0x00	; 0
 4c0:	12 c0       	rjmp	.+36     	; 0x4e6 <__vector_16+0xda>

	   }
       else if ( sensor_count == 3 )   //  초음파센서 3 트리거 신호 발생(초음파 3 발사)
 4c2:	80 91 67 01 	lds	r24, 0x0167
 4c6:	90 91 68 01 	lds	r25, 0x0168
 4ca:	03 97       	sbiw	r24, 0x03	; 3
 4cc:	81 f4       	brne	.+32     	; 0x4ee <__vector_16+0xe2>
	   {
	      PORTB |= 0x04;    // PB2 : High
 4ce:	c2 9a       	sbi	0x18, 2	; 24
 4d0:	84 e1       	ldi	r24, 0x14	; 20
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	35 e0       	ldi	r19, 0x05	; 5
 4d6:	23 2f       	mov	r18, r19
 4d8:	2a 95       	dec	r18
 4da:	f1 f7       	brne	.-4      	; 0x4d8 <__vector_16+0xcc>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 4dc:	01 97       	sbiw	r24, 0x01	; 1
 4de:	d9 f7       	brne	.-10     	; 0x4d6 <__vector_16+0xca>
	   }
       else if ( sensor_count == 3 )   //  초음파센서 3 트리거 신호 발생(초음파 3 발사)
	   {
	      PORTB |= 0x04;    // PB2 : High
		  usec_delay(20) ;  // 20usec 동안 High 유지 
	      PORTB &= ~0x04;   // PB2 : Low 
 4e0:	c2 98       	cbi	0x18, 2	; 24

		  active_sensor_flag = 3;
 4e2:	83 e0       	ldi	r24, 0x03	; 3
 4e4:	90 e0       	ldi	r25, 0x00	; 0
 4e6:	90 93 42 01 	sts	0x0142, r25
 4ea:	80 93 41 01 	sts	0x0141, r24


       ////////  경고음 발생   /////////////

 
       if( distance_1 <=  40 )    Warning_Flag = 1 ;     // 측정된 거리가 40 cm 이하이면 경고음 발생 플래그 set
 4ee:	80 91 5b 01 	lds	r24, 0x015B
 4f2:	90 91 5c 01 	lds	r25, 0x015C
 4f6:	89 97       	sbiw	r24, 0x29	; 41
 4f8:	20 f4       	brcc	.+8      	; 0x502 <__vector_16+0xf6>
 4fa:	81 e0       	ldi	r24, 0x01	; 1
 4fc:	80 93 69 01 	sts	0x0169, r24
 500:	02 c0       	rjmp	.+4      	; 0x506 <__vector_16+0xfa>
       else                       Warning_Flag = 0 ;    
 502:	10 92 69 01 	sts	0x0169, r1
		
       Delay_Time =  distance_1 / 10 + 1;            // 거리에 비레하는 주기(= Delay_Time * 50 msec )를 갖는 경고음 발생
 506:	80 91 5b 01 	lds	r24, 0x015B
 50a:	90 91 5c 01 	lds	r25, 0x015C
 50e:	6a e0       	ldi	r22, 0x0A	; 10
 510:	70 e0       	ldi	r23, 0x00	; 0
 512:	0e 94 ac 05 	call	0xb58	; 0xb58 <__udivmodhi4>
 516:	6f 5f       	subi	r22, 0xFF	; 255
 518:	7f 4f       	sbci	r23, 0xFF	; 255
 51a:	70 93 6b 01 	sts	0x016B, r23
 51e:	60 93 6a 01 	sts	0x016A, r22
        
	   if( Delay_Time <= 1)   Delay_Time = 1 ;   // 경고음주기 하한 : 0.1초
 522:	80 91 6a 01 	lds	r24, 0x016A
 526:	90 91 6b 01 	lds	r25, 0x016B
 52a:	02 97       	sbiw	r24, 0x02	; 2
 52c:	30 f4       	brcc	.+12     	; 0x53a <__vector_16+0x12e>
 52e:	81 e0       	ldi	r24, 0x01	; 1
 530:	90 e0       	ldi	r25, 0x00	; 0
 532:	90 93 6b 01 	sts	0x016B, r25
 536:	80 93 6a 01 	sts	0x016A, r24
	   if( Delay_Time >= 4)   Delay_Time = 4 ;   // 경고음주기 상한 : 0.4초 
 53a:	80 91 6a 01 	lds	r24, 0x016A
 53e:	90 91 6b 01 	lds	r25, 0x016B
 542:	04 97       	sbiw	r24, 0x04	; 4
 544:	30 f0       	brcs	.+12     	; 0x552 <__vector_16+0x146>
 546:	84 e0       	ldi	r24, 0x04	; 4
 548:	90 e0       	ldi	r25, 0x00	; 0
 54a:	90 93 6b 01 	sts	0x016B, r25
 54e:	80 93 6a 01 	sts	0x016A, r24
 

       if( Warning_Flag == 1 )
 552:	80 91 69 01 	lds	r24, 0x0169
 556:	81 30       	cpi	r24, 0x01	; 1
 558:	e9 f4       	brne	.+58     	; 0x594 <__vector_16+0x188>
	   {
           if( Time_Delay_Polling( Delay_Time ) == 1 )     // 50msec * Delay_Time 경과 후 
 55a:	20 91 6a 01 	lds	r18, 0x016A
 55e:	30 91 6b 01 	lds	r19, 0x016B

    static unsigned short  curr_delay = 0; 
	unsigned char  ret_val = 0;


    curr_delay++ ;  
 562:	80 91 3a 01 	lds	r24, 0x013A
 566:	90 91 3b 01 	lds	r25, 0x013B
 56a:	01 96       	adiw	r24, 0x01	; 1
 56c:	90 93 3b 01 	sts	0x013B, r25
 570:	80 93 3a 01 	sts	0x013A, r24

    if( curr_delay >= d_time )   // 50msec * d_time 경과 후 
 574:	82 17       	cp	r24, r18
 576:	93 07       	cpc	r25, r19
 578:	98 f0       	brcs	.+38     	; 0x5a0 <__vector_16+0x194>
	{
       ret_val = 1; 
       curr_delay = 0 ;
 57a:	10 92 3b 01 	sts	0x013B, r1
 57e:	10 92 3a 01 	sts	0x013A, r1

       if( Warning_Flag == 1 )
	   {
           if( Time_Delay_Polling( Delay_Time ) == 1 )     // 50msec * Delay_Time 경과 후 
	       {
               PORTB ^= 0x08  ;    // PB3(버저) toggle : 버저 단속음 
 582:	88 b3       	in	r24, 0x18	; 24
 584:	98 e0       	ldi	r25, 0x08	; 8
 586:	89 27       	eor	r24, r25
 588:	88 bb       	out	0x18, r24	; 24
			   PORTB ^= 0x10  ;    // PB4(LED) toggle :  LED ON, OFF 반복 
 58a:	88 b3       	in	r24, 0x18	; 24
 58c:	90 e1       	ldi	r25, 0x10	; 16
 58e:	89 27       	eor	r24, r25
 590:	88 bb       	out	0x18, r24	; 24
 592:	06 c0       	rjmp	.+12     	; 0x5a0 <__vector_16+0x194>
	       }
	   }
       else if( Warning_Flag == 0 )
 594:	80 91 69 01 	lds	r24, 0x0169
 598:	88 23       	and	r24, r24
 59a:	11 f4       	brne	.+4      	; 0x5a0 <__vector_16+0x194>
	   {
           PORTB &= ~0x08  ;    // PB3(버저) OFF : 버저 OFF 
 59c:	c3 98       	cbi	0x18, 3	; 24
		   PORTB |= 0x10  ;     // PB4(LED) OFF :  LED  OFF 
 59e:	c4 9a       	sbi	0x18, 4	; 24


   }


}
 5a0:	bf 91       	pop	r27
 5a2:	af 91       	pop	r26
 5a4:	9f 91       	pop	r25
 5a6:	8f 91       	pop	r24
 5a8:	7f 91       	pop	r23
 5aa:	6f 91       	pop	r22
 5ac:	5f 91       	pop	r21
 5ae:	3f 91       	pop	r19
 5b0:	2f 91       	pop	r18
 5b2:	0f 90       	pop	r0
 5b4:	0f be       	out	0x3f, r0	; 63
 5b6:	0f 90       	pop	r0
 5b8:	1f 90       	pop	r1
 5ba:	18 95       	reti

000005bc <__vector_5>:



ISR(INT4_vect)
{
 5bc:	1f 92       	push	r1
 5be:	0f 92       	push	r0
 5c0:	0f b6       	in	r0, 0x3f	; 63
 5c2:	0f 92       	push	r0
 5c4:	11 24       	eor	r1, r1
 5c6:	2f 93       	push	r18
 5c8:	3f 93       	push	r19
 5ca:	5f 93       	push	r21
 5cc:	6f 93       	push	r22
 5ce:	7f 93       	push	r23
 5d0:	8f 93       	push	r24
 5d2:	9f 93       	push	r25
 5d4:	af 93       	push	r26
 5d6:	bf 93       	push	r27

    static unsigned short count1 = 0, count2 = 0, del_T = 0, flag = 0 ;

    if ( active_sensor_flag == 1 )
 5d8:	20 91 41 01 	lds	r18, 0x0141
 5dc:	30 91 42 01 	lds	r19, 0x0142
 5e0:	21 30       	cpi	r18, 0x01	; 1
 5e2:	31 05       	cpc	r19, r1
 5e4:	09 f0       	breq	.+2      	; 0x5e8 <__vector_5+0x2c>
 5e6:	4c c0       	rjmp	.+152    	; 0x680 <__vector_5+0xc4>
 	{

	   if(flag == 0) 
 5e8:	80 91 5f 01 	lds	r24, 0x015F
 5ec:	90 91 60 01 	lds	r25, 0x0160
 5f0:	89 2b       	or	r24, r25
 5f2:	69 f4       	brne	.+26     	; 0x60e <__vector_5+0x52>
	   {
		  count1 = TCNT3; 
 5f4:	80 91 88 00 	lds	r24, 0x0088
 5f8:	90 91 89 00 	lds	r25, 0x0089
 5fc:	90 93 66 01 	sts	0x0166, r25
 600:	80 93 65 01 	sts	0x0165, r24
		  flag = 1;
 604:	30 93 60 01 	sts	0x0160, r19
 608:	20 93 5f 01 	sts	0x015F, r18
 60c:	39 c0       	rjmp	.+114    	; 0x680 <__vector_5+0xc4>
	  } 
	  else 
	  { 
		  count2 = TCNT3; 
 60e:	80 91 88 00 	lds	r24, 0x0088
 612:	90 91 89 00 	lds	r25, 0x0089
 616:	90 93 64 01 	sts	0x0164, r25
 61a:	80 93 63 01 	sts	0x0163, r24
		  del_T = count2 - count1;
 61e:	20 91 65 01 	lds	r18, 0x0165
 622:	30 91 66 01 	lds	r19, 0x0166
 626:	82 1b       	sub	r24, r18
 628:	93 0b       	sbc	r25, r19
 62a:	90 93 62 01 	sts	0x0162, r25
 62e:	80 93 61 01 	sts	0x0161, r24

    	  distance_1 = del_T/(2*58); 
 632:	64 e7       	ldi	r22, 0x74	; 116
 634:	70 e0       	ldi	r23, 0x00	; 0
 636:	0e 94 ac 05 	call	0xb58	; 0xb58 <__udivmodhi4>
 63a:	70 93 5c 01 	sts	0x015C, r23
 63e:	60 93 5b 01 	sts	0x015B, r22

          if( distance_1 > 380 )  // 반사되는 초음파가 검출되지 않을때 
 642:	80 91 5b 01 	lds	r24, 0x015B
 646:	90 91 5c 01 	lds	r25, 0x015C
 64a:	8d 57       	subi	r24, 0x7D	; 125
 64c:	91 40       	sbci	r25, 0x01	; 1
 64e:	40 f0       	brcs	.+16     	; 0x660 <__vector_5+0xa4>
		  {
		      distance_1 = distance_1_old ;   // 직전 측정값 사용 
 650:	80 91 5d 01 	lds	r24, 0x015D
 654:	90 91 5e 01 	lds	r25, 0x015E
 658:	90 93 5c 01 	sts	0x015C, r25
 65c:	80 93 5b 01 	sts	0x015B, r24
		  } 

          distance_1_old = distance_1 ;    // 직전 측정값 저장 변수 업데이트  
 660:	80 91 5b 01 	lds	r24, 0x015B
 664:	90 91 5c 01 	lds	r25, 0x015C
 668:	90 93 5e 01 	sts	0x015E, r25
 66c:	80 93 5d 01 	sts	0x015D, r24

		  flag = 0; 
 670:	10 92 60 01 	sts	0x0160, r1
 674:	10 92 5f 01 	sts	0x015F, r1

	 	  active_sensor_flag = 0;
 678:	10 92 42 01 	sts	0x0142, r1
 67c:	10 92 41 01 	sts	0x0141, r1
	  } 

    }

} 
 680:	bf 91       	pop	r27
 682:	af 91       	pop	r26
 684:	9f 91       	pop	r25
 686:	8f 91       	pop	r24
 688:	7f 91       	pop	r23
 68a:	6f 91       	pop	r22
 68c:	5f 91       	pop	r21
 68e:	3f 91       	pop	r19
 690:	2f 91       	pop	r18
 692:	0f 90       	pop	r0
 694:	0f be       	out	0x3f, r0	; 63
 696:	0f 90       	pop	r0
 698:	1f 90       	pop	r1
 69a:	18 95       	reti

0000069c <__vector_6>:


ISR(INT5_vect)
{
 69c:	1f 92       	push	r1
 69e:	0f 92       	push	r0
 6a0:	0f b6       	in	r0, 0x3f	; 63
 6a2:	0f 92       	push	r0
 6a4:	11 24       	eor	r1, r1
 6a6:	2f 93       	push	r18
 6a8:	3f 93       	push	r19
 6aa:	5f 93       	push	r21
 6ac:	6f 93       	push	r22
 6ae:	7f 93       	push	r23
 6b0:	8f 93       	push	r24
 6b2:	9f 93       	push	r25
 6b4:	af 93       	push	r26
 6b6:	bf 93       	push	r27

    static unsigned short count1 = 0, count2 = 0, del_T = 0, flag = 0 ;


    if ( active_sensor_flag == 2 )
 6b8:	80 91 41 01 	lds	r24, 0x0141
 6bc:	90 91 42 01 	lds	r25, 0x0142
 6c0:	02 97       	sbiw	r24, 0x02	; 2
 6c2:	09 f0       	breq	.+2      	; 0x6c6 <__vector_6+0x2a>
 6c4:	4e c0       	rjmp	.+156    	; 0x762 <__vector_6+0xc6>
	{

	   if(flag == 0) 
 6c6:	80 91 53 01 	lds	r24, 0x0153
 6ca:	90 91 54 01 	lds	r25, 0x0154
 6ce:	89 2b       	or	r24, r25
 6d0:	79 f4       	brne	.+30     	; 0x6f0 <__vector_6+0x54>
	   {
		  count1 = TCNT3; 
 6d2:	80 91 88 00 	lds	r24, 0x0088
 6d6:	90 91 89 00 	lds	r25, 0x0089
 6da:	90 93 5a 01 	sts	0x015A, r25
 6de:	80 93 59 01 	sts	0x0159, r24
		  flag = 1;
 6e2:	81 e0       	ldi	r24, 0x01	; 1
 6e4:	90 e0       	ldi	r25, 0x00	; 0
 6e6:	90 93 54 01 	sts	0x0154, r25
 6ea:	80 93 53 01 	sts	0x0153, r24
 6ee:	39 c0       	rjmp	.+114    	; 0x762 <__vector_6+0xc6>
	  } 
	  else 
	  { 
		  count2 = TCNT3; 
 6f0:	80 91 88 00 	lds	r24, 0x0088
 6f4:	90 91 89 00 	lds	r25, 0x0089
 6f8:	90 93 58 01 	sts	0x0158, r25
 6fc:	80 93 57 01 	sts	0x0157, r24
		  del_T = count2 - count1;
 700:	20 91 59 01 	lds	r18, 0x0159
 704:	30 91 5a 01 	lds	r19, 0x015A
 708:	82 1b       	sub	r24, r18
 70a:	93 0b       	sbc	r25, r19
 70c:	90 93 56 01 	sts	0x0156, r25
 710:	80 93 55 01 	sts	0x0155, r24
    	  distance_2 = del_T/(2*58); 
 714:	64 e7       	ldi	r22, 0x74	; 116
 716:	70 e0       	ldi	r23, 0x00	; 0
 718:	0e 94 ac 05 	call	0xb58	; 0xb58 <__udivmodhi4>
 71c:	70 93 50 01 	sts	0x0150, r23
 720:	60 93 4f 01 	sts	0x014F, r22

          if( distance_2 > 380 )  // 반사되는 초음파가 검출되지 않을때 
 724:	80 91 4f 01 	lds	r24, 0x014F
 728:	90 91 50 01 	lds	r25, 0x0150
 72c:	8d 57       	subi	r24, 0x7D	; 125
 72e:	91 40       	sbci	r25, 0x01	; 1
 730:	40 f0       	brcs	.+16     	; 0x742 <__vector_6+0xa6>
		  {
		      distance_2 = distance_2_old ;   // 직전 측정값 사용 
 732:	80 91 51 01 	lds	r24, 0x0151
 736:	90 91 52 01 	lds	r25, 0x0152
 73a:	90 93 50 01 	sts	0x0150, r25
 73e:	80 93 4f 01 	sts	0x014F, r24
		  } 

          distance_2_old = distance_2 ;    // 직전 측정값 저장 변수 업데이트  
 742:	80 91 4f 01 	lds	r24, 0x014F
 746:	90 91 50 01 	lds	r25, 0x0150
 74a:	90 93 52 01 	sts	0x0152, r25
 74e:	80 93 51 01 	sts	0x0151, r24

		  flag = 0; 
 752:	10 92 54 01 	sts	0x0154, r1
 756:	10 92 53 01 	sts	0x0153, r1

	 	  active_sensor_flag = 0;
 75a:	10 92 42 01 	sts	0x0142, r1
 75e:	10 92 41 01 	sts	0x0141, r1
	  } 

    }

} 
 762:	bf 91       	pop	r27
 764:	af 91       	pop	r26
 766:	9f 91       	pop	r25
 768:	8f 91       	pop	r24
 76a:	7f 91       	pop	r23
 76c:	6f 91       	pop	r22
 76e:	5f 91       	pop	r21
 770:	3f 91       	pop	r19
 772:	2f 91       	pop	r18
 774:	0f 90       	pop	r0
 776:	0f be       	out	0x3f, r0	; 63
 778:	0f 90       	pop	r0
 77a:	1f 90       	pop	r1
 77c:	18 95       	reti

0000077e <__vector_7>:



ISR(INT6_vect)
{
 77e:	1f 92       	push	r1
 780:	0f 92       	push	r0
 782:	0f b6       	in	r0, 0x3f	; 63
 784:	0f 92       	push	r0
 786:	11 24       	eor	r1, r1
 788:	2f 93       	push	r18
 78a:	3f 93       	push	r19
 78c:	5f 93       	push	r21
 78e:	6f 93       	push	r22
 790:	7f 93       	push	r23
 792:	8f 93       	push	r24
 794:	9f 93       	push	r25
 796:	af 93       	push	r26
 798:	bf 93       	push	r27

    static unsigned short count1 = 0, count2 = 0, del_T = 0, flag = 0 ;

    if ( active_sensor_flag == 3 )
 79a:	80 91 41 01 	lds	r24, 0x0141
 79e:	90 91 42 01 	lds	r25, 0x0142
 7a2:	03 97       	sbiw	r24, 0x03	; 3
 7a4:	09 f0       	breq	.+2      	; 0x7a8 <__vector_7+0x2a>
 7a6:	4e c0       	rjmp	.+156    	; 0x844 <__vector_7+0xc6>
	{

	   if(flag == 0) 
 7a8:	80 91 47 01 	lds	r24, 0x0147
 7ac:	90 91 48 01 	lds	r25, 0x0148
 7b0:	89 2b       	or	r24, r25
 7b2:	79 f4       	brne	.+30     	; 0x7d2 <__vector_7+0x54>
	   {
		  count1 = TCNT3; 
 7b4:	80 91 88 00 	lds	r24, 0x0088
 7b8:	90 91 89 00 	lds	r25, 0x0089
 7bc:	90 93 4e 01 	sts	0x014E, r25
 7c0:	80 93 4d 01 	sts	0x014D, r24
		  flag = 1;
 7c4:	81 e0       	ldi	r24, 0x01	; 1
 7c6:	90 e0       	ldi	r25, 0x00	; 0
 7c8:	90 93 48 01 	sts	0x0148, r25
 7cc:	80 93 47 01 	sts	0x0147, r24
 7d0:	39 c0       	rjmp	.+114    	; 0x844 <__vector_7+0xc6>
	  } 
	  else 
	  { 
		  count2 = TCNT3; 
 7d2:	80 91 88 00 	lds	r24, 0x0088
 7d6:	90 91 89 00 	lds	r25, 0x0089
 7da:	90 93 4c 01 	sts	0x014C, r25
 7de:	80 93 4b 01 	sts	0x014B, r24
		  del_T = count2 - count1;
 7e2:	20 91 4d 01 	lds	r18, 0x014D
 7e6:	30 91 4e 01 	lds	r19, 0x014E
 7ea:	82 1b       	sub	r24, r18
 7ec:	93 0b       	sbc	r25, r19
 7ee:	90 93 4a 01 	sts	0x014A, r25
 7f2:	80 93 49 01 	sts	0x0149, r24
    	  distance_3 = del_T/(2*58); 
 7f6:	64 e7       	ldi	r22, 0x74	; 116
 7f8:	70 e0       	ldi	r23, 0x00	; 0
 7fa:	0e 94 ac 05 	call	0xb58	; 0xb58 <__udivmodhi4>
 7fe:	70 93 44 01 	sts	0x0144, r23
 802:	60 93 43 01 	sts	0x0143, r22

          if( distance_3 > 380 )  // 반사되는 초음파가 검출되지 않을때 
 806:	80 91 43 01 	lds	r24, 0x0143
 80a:	90 91 44 01 	lds	r25, 0x0144
 80e:	8d 57       	subi	r24, 0x7D	; 125
 810:	91 40       	sbci	r25, 0x01	; 1
 812:	40 f0       	brcs	.+16     	; 0x824 <__vector_7+0xa6>
		  {
		      distance_3 = distance_3_old ;   // 직전 측정값 사용 
 814:	80 91 45 01 	lds	r24, 0x0145
 818:	90 91 46 01 	lds	r25, 0x0146
 81c:	90 93 44 01 	sts	0x0144, r25
 820:	80 93 43 01 	sts	0x0143, r24
		  } 

          distance_3_old = distance_3 ;    // 직전 측정값 저장 변수 업데이트  
 824:	80 91 43 01 	lds	r24, 0x0143
 828:	90 91 44 01 	lds	r25, 0x0144
 82c:	90 93 46 01 	sts	0x0146, r25
 830:	80 93 45 01 	sts	0x0145, r24

		  flag = 0; 
 834:	10 92 48 01 	sts	0x0148, r1
 838:	10 92 47 01 	sts	0x0147, r1

	 	  active_sensor_flag = 0;
 83c:	10 92 42 01 	sts	0x0142, r1
 840:	10 92 41 01 	sts	0x0141, r1
	  } 

    }

} 
 844:	bf 91       	pop	r27
 846:	af 91       	pop	r26
 848:	9f 91       	pop	r25
 84a:	8f 91       	pop	r24
 84c:	7f 91       	pop	r23
 84e:	6f 91       	pop	r22
 850:	5f 91       	pop	r21
 852:	3f 91       	pop	r19
 854:	2f 91       	pop	r18
 856:	0f 90       	pop	r0
 858:	0f be       	out	0x3f, r0	; 63
 85a:	0f 90       	pop	r0
 85c:	1f 90       	pop	r1
 85e:	18 95       	reti

00000860 <HexToDec>:

}


void HexToDec( unsigned short num, unsigned short radix) 
{
 860:	0f 93       	push	r16
 862:	1f 93       	push	r17
 864:	cf 93       	push	r28
 866:	df 93       	push	r29
 868:	9c 01       	movw	r18, r24
 86a:	8b 01       	movw	r16, r22
	int j ;

	for(j=0; j<5 ; j++) cnumber[j] = 0 ;
 86c:	10 92 3c 01 	sts	0x013C, r1
 870:	10 92 3d 01 	sts	0x013D, r1
 874:	10 92 3e 01 	sts	0x013E, r1
 878:	10 92 3f 01 	sts	0x013F, r1
 87c:	10 92 40 01 	sts	0x0140, r1
 880:	c0 e0       	ldi	r28, 0x00	; 0
 882:	d0 e0       	ldi	r29, 0x00	; 0

	j=0;
	do
	{
		cnumber[j++] = num % radix ; 
 884:	c9 01       	movw	r24, r18
 886:	b8 01       	movw	r22, r16
 888:	0e 94 ac 05 	call	0xb58	; 0xb58 <__udivmodhi4>
 88c:	fe 01       	movw	r30, r28
 88e:	e4 5c       	subi	r30, 0xC4	; 196
 890:	fe 4f       	sbci	r31, 0xFE	; 254
 892:	80 83       	st	Z, r24
 894:	21 96       	adiw	r28, 0x01	; 1
		num /= radix; 
 896:	c9 01       	movw	r24, r18
 898:	b8 01       	movw	r22, r16
 89a:	0e 94 ac 05 	call	0xb58	; 0xb58 <__udivmodhi4>
 89e:	9b 01       	movw	r18, r22

	} while(num);
 8a0:	61 15       	cp	r22, r1
 8a2:	71 05       	cpc	r23, r1
 8a4:	79 f7       	brne	.-34     	; 0x884 <HexToDec+0x24>

} 
 8a6:	df 91       	pop	r29
 8a8:	cf 91       	pop	r28
 8aa:	1f 91       	pop	r17
 8ac:	0f 91       	pop	r16
 8ae:	08 95       	ret

000008b0 <NumToAsc>:

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 8b0:	8a 30       	cpi	r24, 0x0A	; 10
 8b2:	10 f4       	brcc	.+4      	; 0x8b8 <NumToAsc+0x8>
 8b4:	80 5d       	subi	r24, 0xD0	; 208
 8b6:	08 95       	ret
	else          Num += 0x37; 
 8b8:	89 5c       	subi	r24, 0xC9	; 201

	return Num ;
}
 8ba:	08 95       	ret

000008bc <msec_delay>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 8bc:	20 ea       	ldi	r18, 0xA0	; 160
 8be:	3f e0       	ldi	r19, 0x0F	; 15
 8c0:	04 c0       	rjmp	.+8      	; 0x8ca <msec_delay+0xe>
 8c2:	f9 01       	movw	r30, r18
 8c4:	31 97       	sbiw	r30, 0x01	; 1
 8c6:	f1 f7       	brne	.-4      	; 0x8c4 <msec_delay+0x8>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 8c8:	01 97       	sbiw	r24, 0x01	; 1
 8ca:	18 16       	cp	r1, r24
 8cc:	19 06       	cpc	r1, r25
 8ce:	cc f3       	brlt	.-14     	; 0x8c2 <msec_delay+0x6>
		_delay_ms(1);		// 1msec 시간 지연
}
 8d0:	08 95       	ret

000008d2 <usec_delay>:
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 8d2:	35 e0       	ldi	r19, 0x05	; 5
 8d4:	04 c0       	rjmp	.+8      	; 0x8de <usec_delay+0xc>
 8d6:	23 2f       	mov	r18, r19
 8d8:	2a 95       	dec	r18
 8da:	f1 f7       	brne	.-4      	; 0x8d8 <usec_delay+0x6>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 8dc:	01 97       	sbiw	r24, 0x01	; 1
 8de:	18 16       	cp	r1, r24
 8e0:	19 06       	cpc	r1, r25
 8e2:	cc f3       	brlt	.-14     	; 0x8d6 <usec_delay+0x4>
		_delay_us(1);		// 1usec 시간 지연
}
 8e4:	08 95       	ret

000008e6 <Time_Delay_Polling>:

    static unsigned short  curr_delay = 0; 
	unsigned char  ret_val = 0;


    curr_delay++ ;  
 8e6:	20 91 3a 01 	lds	r18, 0x013A
 8ea:	30 91 3b 01 	lds	r19, 0x013B
 8ee:	2f 5f       	subi	r18, 0xFF	; 255
 8f0:	3f 4f       	sbci	r19, 0xFF	; 255
 8f2:	30 93 3b 01 	sts	0x013B, r19
 8f6:	20 93 3a 01 	sts	0x013A, r18

    if( curr_delay >= d_time )   // 50msec * d_time 경과 후 
 8fa:	28 17       	cp	r18, r24
 8fc:	39 07       	cpc	r19, r25
 8fe:	10 f4       	brcc	.+4      	; 0x904 <Time_Delay_Polling+0x1e>
 900:	80 e0       	ldi	r24, 0x00	; 0
 902:	08 95       	ret
	{
       ret_val = 1; 
       curr_delay = 0 ;
 904:	10 92 3b 01 	sts	0x013B, r1
 908:	10 92 3a 01 	sts	0x013A, r1
 90c:	81 e0       	ldi	r24, 0x01	; 1


    return  ret_val ;


}
 90e:	08 95       	ret

00000910 <Display_Number_LCD>:

} 


void Display_Number_LCD( unsigned int num, unsigned char digit )       // 부호없는 정수형 변수를 10진수 형태로 LCD 에 디스플레이 
{
 910:	1f 93       	push	r17
 912:	16 2f       	mov	r17, r22

	HexToDec( num, 10); //10진수로 변환 
 914:	6a e0       	ldi	r22, 0x0A	; 10
 916:	70 e0       	ldi	r23, 0x00	; 0
 918:	0e 94 30 04 	call	0x860	; 0x860 <HexToDec>

	if( digit == 0 )     digit = 1 ;
 91c:	11 23       	and	r17, r17
 91e:	81 f1       	breq	.+96     	; 0x980 <Display_Number_LCD+0x70>
	if( digit > 5 )      digit = 5 ;
 920:	16 30       	cpi	r17, 0x06	; 6
 922:	10 f0       	brcs	.+4      	; 0x928 <Display_Number_LCD+0x18>
 924:	15 e0       	ldi	r17, 0x05	; 5
 926:	02 c0       	rjmp	.+4      	; 0x92c <Display_Number_LCD+0x1c>
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
 928:	15 30       	cpi	r17, 0x05	; 5
 92a:	49 f4       	brne	.+18     	; 0x93e <Display_Number_LCD+0x2e>
 92c:	80 91 40 01 	lds	r24, 0x0140

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 930:	8a 30       	cpi	r24, 0x0A	; 10
 932:	10 f4       	brcc	.+4      	; 0x938 <Display_Number_LCD+0x28>
 934:	80 5d       	subi	r24, 0xD0	; 208
 936:	01 c0       	rjmp	.+2      	; 0x93a <Display_Number_LCD+0x2a>
	else          Num += 0x37; 
 938:	89 5c       	subi	r24, 0xC9	; 201
	HexToDec( num, 10); //10진수로 변환 

	if( digit == 0 )     digit = 1 ;
	if( digit > 5 )      digit = 5 ;
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
 93a:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 
 93e:	14 30       	cpi	r17, 0x04	; 4
 940:	48 f0       	brcs	.+18     	; 0x954 <Display_Number_LCD+0x44>
 942:	80 91 3f 01 	lds	r24, 0x013F

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 946:	8a 30       	cpi	r24, 0x0A	; 10
 948:	10 f4       	brcc	.+4      	; 0x94e <Display_Number_LCD+0x3e>
 94a:	80 5d       	subi	r24, 0xD0	; 208
 94c:	01 c0       	rjmp	.+2      	; 0x950 <Display_Number_LCD+0x40>
	else          Num += 0x37; 
 94e:	89 5c       	subi	r24, 0xC9	; 201
	if( digit == 0 )     digit = 1 ;
	if( digit > 5 )      digit = 5 ;
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 
 950:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 
 954:	13 30       	cpi	r17, 0x03	; 3
 956:	48 f0       	brcs	.+18     	; 0x96a <Display_Number_LCD+0x5a>
 958:	80 91 3e 01 	lds	r24, 0x013E

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 95c:	8a 30       	cpi	r24, 0x0A	; 10
 95e:	10 f4       	brcc	.+4      	; 0x964 <Display_Number_LCD+0x54>
 960:	80 5d       	subi	r24, 0xD0	; 208
 962:	01 c0       	rjmp	.+2      	; 0x966 <Display_Number_LCD+0x56>
	else          Num += 0x37; 
 964:	89 5c       	subi	r24, 0xC9	; 201
 
    if( digit >= 5 )     LcdPutchar( NumToAsc(cnumber[4]) );  // 10000자리 디스플레이
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 
 966:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이
 96a:	11 30       	cpi	r17, 0x01	; 1
 96c:	49 f0       	breq	.+18     	; 0x980 <Display_Number_LCD+0x70>
 96e:	80 91 3d 01 	lds	r24, 0x013D

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 972:	8a 30       	cpi	r24, 0x0A	; 10
 974:	10 f4       	brcc	.+4      	; 0x97a <Display_Number_LCD+0x6a>
 976:	80 5d       	subi	r24, 0xD0	; 208
 978:	01 c0       	rjmp	.+2      	; 0x97c <Display_Number_LCD+0x6c>
	else          Num += 0x37; 
 97a:	89 5c       	subi	r24, 0xC9	; 201
	
	if( digit >= 4 )     LcdPutchar(NumToAsc(cnumber[3]));    // 1000자리 디스플레이 

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이
 97c:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>

	if( digit >= 1 )     LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 980:	80 91 3c 01 	lds	r24, 0x013C

} 

char NumToAsc( unsigned char Num )
{
	if( Num <10 ) Num += 0x30; 
 984:	8a 30       	cpi	r24, 0x0A	; 10
 986:	10 f4       	brcc	.+4      	; 0x98c <Display_Number_LCD+0x7c>
 988:	80 5d       	subi	r24, 0xD0	; 208
 98a:	01 c0       	rjmp	.+2      	; 0x98e <Display_Number_LCD+0x7e>
	else          Num += 0x37; 
 98c:	89 5c       	subi	r24, 0xC9	; 201

	if( digit >= 3 )     LcdPutchar(NumToAsc(cnumber[2]));    // 100자리 디스플레이 

	if( digit >= 2 )     LcdPutchar(NumToAsc(cnumber[1]));    // 10자리 디스플레이

	if( digit >= 1 )     LcdPutchar(NumToAsc(cnumber[0]));    //  1자리 디스플레이
 98e:	0e 94 67 00 	call	0xce	; 0xce <LcdPutchar>

}
 992:	1f 91       	pop	r17
 994:	08 95       	ret

00000996 <main>:
static volatile  unsigned char    Warning_Flag = 0 ;
static volatile  unsigned short   Delay_Time = 0;


int main() 
{   
 996:	cf 93       	push	r28
 998:	df 93       	push	r29

////  3 개의 초음파센서( Ultrasonic Sensor) ////////////

// 출력포트 설정 
	
	DDRB |= 0x07;     // 3 초음파센서 Trigger signals( PB0, PB1, PB2 : 출력포트 설정  )
 99a:	87 b3       	in	r24, 0x17	; 23
 99c:	87 60       	ori	r24, 0x07	; 7
 99e:	87 bb       	out	0x17, r24	; 23
	PORTB &= ~0x07;   // PB0, PB1, PB2  : Low  ( 3 Trigger signals OFF )  
 9a0:	88 b3       	in	r24, 0x18	; 24
 9a2:	88 7f       	andi	r24, 0xF8	; 248
 9a4:	88 bb       	out	0x18, r24	; 24

	DDRB |= 0x08;     // 버저(Buzzer) ( PB3 : 출력포트 설정    )
 9a6:	bb 9a       	sbi	0x17, 3	; 23
	PORTB &= ~0x08;   // PB3  : Low  ( 버저 OFF )  
 9a8:	c3 98       	cbi	0x18, 3	; 24

	DDRB |= 0x10;     // LED ( PB4 : 출력포트 설정    )
 9aa:	bc 9a       	sbi	0x17, 4	; 23
	PORTB |= 0x10;    // PB4  : High ( LED OFF)    
 9ac:	c4 9a       	sbi	0x18, 4	; 24



	DDRB |= 0x20;   // 왼쪽 모터구동신호 + 단자:  PWM 포트( pin: OC1A(PB5) )   --> 출력 설정 
 9ae:	bd 9a       	sbi	0x17, 5	; 23
	DDRA |= 0x01;   // 왼쪽 모터구동신호 - 단자 : 범용 입/출력포트(pin : PA0 ) --> 출력 설정 
 9b0:	d0 9a       	sbi	0x1a, 0	; 26

	DDRB |= 0x40;   // 오른쪽 모터구동신호 + 단자:  PWM 포트( pin: OC1A(PB6) )   --> 출력 설정 
 9b2:	be 9a       	sbi	0x17, 6	; 23
	DDRA |= 0x02;   // 오른쪽 모터구동신호 - 단자 : 범용 입/출력포트(pin : PA1 ) --> 출력 설정 
 9b4:	d1 9a       	sbi	0x1a, 1	; 26
	 

///////////////////////

	LcdInit();
 9b6:	0e 94 e9 00 	call	0x1d2	; 0x1d2 <LcdInit>

	LcdMove(0,0); 
 9ba:	80 e0       	ldi	r24, 0x00	; 0
 9bc:	60 e0       	ldi	r22, 0x00	; 0
 9be:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LcdMove>
	LcdPuts("DC Motor Control");
 9c2:	80 e0       	ldi	r24, 0x00	; 0
 9c4:	91 e0       	ldi	r25, 0x01	; 1
 9c6:	0e 94 83 00 	call	0x106	; 0x106 <LcdPuts>

	LcdMove(1,0); 
 9ca:	81 e0       	ldi	r24, 0x01	; 1
 9cc:	60 e0       	ldi	r22, 0x00	; 0
 9ce:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LcdMove>
	LcdPuts("UltrasonicSensor");
 9d2:	81 e1       	ldi	r24, 0x11	; 17
 9d4:	91 e0       	ldi	r25, 0x01	; 1
 9d6:	0e 94 83 00 	call	0x106	; 0x106 <LcdPuts>
 9da:	80 ed       	ldi	r24, 0xD0	; 208
 9dc:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 9de:	20 ea       	ldi	r18, 0xA0	; 160
 9e0:	3f e0       	ldi	r19, 0x0F	; 15
 9e2:	f9 01       	movw	r30, r18
 9e4:	31 97       	sbiw	r30, 0x01	; 1
 9e6:	f1 f7       	brne	.-4      	; 0x9e4 <main+0x4e>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 9e8:	01 97       	sbiw	r24, 0x01	; 1
 9ea:	d9 f7       	brne	.-10     	; 0x9e2 <main+0x4c>
	LcdMove(1,0); 
	LcdPuts("UltrasonicSensor");

    msec_delay(2000) ;   // 2초간 디스플레이 

    LcdCommand( ALLCLR ) ;   // LCD 화면 지움 
 9ec:	81 e0       	ldi	r24, 0x01	; 1
 9ee:	0e 94 a0 00 	call	0x140	; 0x140 <LcdCommand>
	LcdMove(0,0); 
 9f2:	80 e0       	ldi	r24, 0x00	; 0
 9f4:	60 e0       	ldi	r22, 0x00	; 0
 9f6:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LcdMove>
	LcdPuts("Speed = ");
 9fa:	82 e2       	ldi	r24, 0x22	; 34
 9fc:	91 e0       	ldi	r25, 0x01	; 1
 9fe:	0e 94 83 00 	call	0x106	; 0x106 <LcdPuts>

	LcdMove(1,0); 
 a02:	81 e0       	ldi	r24, 0x01	; 1
 a04:	60 e0       	ldi	r22, 0x00	; 0
 a06:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LcdMove>
	LcdPuts("Dist_1 =    cm");
 a0a:	8b e2       	ldi	r24, 0x2B	; 43
 a0c:	91 e0       	ldi	r25, 0x01	; 1
 a0e:	0e 94 83 00 	call	0x106	; 0x106 <LcdPuts>

/////////////    Timer1 설정 :  Fast PWM Mode    ////////////////////////

// 왼쪽, 오른쪽 모터 구동 PWM 신호 ( pin: OC1A(PB5)), OC1B(PB6) ),   Timer1,  PWM signal (period= 200 usec )

	TCCR1A = 0xA2;    // OC1A(PB5)), OC1B(PB6) :  PWM 포트 설정,   Fast PWM ( mode 14 )
 a12:	82 ea       	ldi	r24, 0xA2	; 162
 a14:	8f bd       	out	0x2f, r24	; 47
	TCCR1B = 0x1B;    // 64 분주 타이머 1 시작 (내부클럭 주기 =  64/(16*10^6) = 4 usec ),  Fast PWM ( mode 14 ) 
 a16:	8b e1       	ldi	r24, 0x1B	; 27
 a18:	8e bd       	out	0x2e, r24	; 46
	ICR1 = 50;        // PWM 주기 = 50 * 4 usec = 200 usec
 a1a:	82 e3       	ldi	r24, 0x32	; 50
 a1c:	90 e0       	ldi	r25, 0x00	; 0
 a1e:	97 bd       	out	0x27, r25	; 39
 a20:	86 bd       	out	0x26, r24	; 38

    Vmax_L = ICR1; 
 a22:	86 b5       	in	r24, 0x26	; 38
 a24:	97 b5       	in	r25, 0x27	; 39
 a26:	90 93 71 01 	sts	0x0171, r25
 a2a:	80 93 70 01 	sts	0x0170, r24
    Vmax_R = ICR1; 
 a2e:	86 b5       	in	r24, 0x26	; 38
 a30:	97 b5       	in	r25, 0x27	; 39
 a32:	90 93 6f 01 	sts	0x016F, r25
 a36:	80 93 6e 01 	sts	0x016E, r24

    Vmax =  ICR1 ;
 a3a:	86 b5       	in	r24, 0x26	; 38
 a3c:	97 b5       	in	r25, 0x27	; 39
 a3e:	90 93 73 01 	sts	0x0173, r25
 a42:	80 93 72 01 	sts	0x0172, r24

//////////////////////////////////////////////////////////////////
    duty_L = 0;
	OCR1A = duty_L;      //  왼쪽 모터 정지: : OC1A(PB5) PWM duty = 0 설정 
 a46:	1b bc       	out	0x2b, r1	; 43
 a48:	1a bc       	out	0x2a, r1	; 42
	
    duty_R = 0;
	OCR1B = duty_R;      //  오른쪽 모터 정지: : OC1B(PB6) PWM duty = 0 설정 	
 a4a:	19 bc       	out	0x29, r1	; 41
 a4c:	18 bc       	out	0x28, r1	; 40
    duty_R = 50;         // 오른쪽 모터 속도 설정, 최대 = Vmax = 50,  최소 = 0 
///////////////////////////////////////////////////////////////////////////

 ////////////  Timer 0 설정  ( 10 msec 주기 타이머 0 인터럽트 )  ///////////////
        
    TCCR0 = 0x00;            // 타이머 0 정지(분주비 = 1024 ) , Normal mode(타이머모드)
 a4e:	13 be       	out	0x33, r1	; 51

    TCNT0 = 256 - 156;       //  내부클럭주기 = 1024/ (16x10^6) = 64 usec,  
 a50:	84 e6       	ldi	r24, 0x64	; 100
 a52:	82 bf       	out	0x32, r24	; 50
                             //  오버플로인터럽트 주기 = 10msec
                             //  156 = 10msec/ 64usec

    TIMSK = 0x01;            // 타이머0 오버플로인터럽트 허용
 a54:	81 e0       	ldi	r24, 0x01	; 1
 a56:	87 bf       	out	0x37, r24	; 55
///////////////////////////////////////////////////////////    


////////////   Timer3  설정 ( 3 Echo Signals Pulse Width measurment )  /////////////

	TCCR3A = 0x00; 
 a58:	10 92 8b 00 	sts	0x008B, r1
	TCCR3B = 0x02;     // 타이머 3 시작(분주비 8) ,  0.5usec 단위로 측정 
 a5c:	82 e0       	ldi	r24, 0x02	; 2
 a5e:	80 93 8a 00 	sts	0x008A, r24

 
// 3 초음파센서 Echo Signals : external interrupt 4( pin: INT4 (PE4)),  external interrupt 5( pin: INT5 (PE5)) 
//                           : external interrupt 6( pin: INT4 (PE6)) 

	EICRB |= 0x15;    // Both falling edge and rising edge interrupt
 a62:	8a b7       	in	r24, 0x3a	; 58
 a64:	85 61       	ori	r24, 0x15	; 21
 a66:	8a bf       	out	0x3a, r24	; 58
	EICRB &= ~0x2A;   // Both falling edge and rising edge interrupt
 a68:	8a b7       	in	r24, 0x3a	; 58
 a6a:	85 7d       	andi	r24, 0xD5	; 213
 a6c:	8a bf       	out	0x3a, r24	; 58

	EIMSK |= 0x70;    // INT4 Enable, INT5 Enable, INT6 Enable
 a6e:	89 b7       	in	r24, 0x39	; 57
 a70:	80 67       	ori	r24, 0x70	; 112
 a72:	89 bf       	out	0x39, r24	; 57
	sei(); 
 a74:	78 94       	sei

///////////////////////////////////////

   //  최초 초음파센서 1 트리거 신호 발생(초음파 1 발사)  
	PORTB |= 0x01;    // PB0 : High
 a76:	c0 9a       	sbi	0x18, 0	; 24
 a78:	84 e1       	ldi	r24, 0x14	; 20
 a7a:	90 e0       	ldi	r25, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 a7c:	35 e0       	ldi	r19, 0x05	; 5
 a7e:	23 2f       	mov	r18, r19
 a80:	2a 95       	dec	r18
 a82:	f1 f7       	brne	.-4      	; 0xa80 <main+0xea>



void usec_delay(int n)
{	
	for(; n>0; n--)		// 1usec 시간 지연을 n회 반복
 a84:	01 97       	sbiw	r24, 0x01	; 1
 a86:	d9 f7       	brne	.-10     	; 0xa7e <main+0xe8>
///////////////////////////////////////

   //  최초 초음파센서 1 트리거 신호 발생(초음파 1 발사)  
	PORTB |= 0x01;    // PB0 : High
	usec_delay(20) ;  // 20usec 동안 High 유지 
	PORTB &= ~0x01;   // PB0 : Low 
 a88:	c0 98       	cbi	0x18, 0	; 24
          
	active_sensor_flag = 1; 
 a8a:	81 e0       	ldi	r24, 0x01	; 1
 a8c:	90 e0       	ldi	r25, 0x00	; 0
 a8e:	90 93 42 01 	sts	0x0142, r25
 a92:	80 93 41 01 	sts	0x0141, r24
    sensor_count = 1;
 a96:	90 93 68 01 	sts	0x0168, r25
 a9a:	80 93 67 01 	sts	0x0167, r24

  /////////////////////////////////////////////


    TCCR0 |= 0x07;    // 타이머 0 시작(분주비 = 1024 ) 
 a9e:	83 b7       	in	r24, 0x33	; 51
 aa0:	87 60       	ori	r24, 0x07	; 7
 aa2:	83 bf       	out	0x33, r24	; 51
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 aa4:	c0 ea       	ldi	r28, 0xA0	; 160
 aa6:	df e0       	ldi	r29, 0x0F	; 15

	 
	while (1) 
	{ 

	    LcdMove(0, 8); 
 aa8:	80 e0       	ldi	r24, 0x00	; 0
 aaa:	68 e0       	ldi	r22, 0x08	; 8
 aac:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LcdMove>
        Display_Number_LCD( duty_L, 2 );          // 왼쪽 모터 속도 디스플레이 
 ab0:	82 e3       	ldi	r24, 0x32	; 50
 ab2:	90 e0       	ldi	r25, 0x00	; 0
 ab4:	62 e0       	ldi	r22, 0x02	; 2
 ab6:	0e 94 88 04 	call	0x910	; 0x910 <Display_Number_LCD>

	    LcdMove(1,9); 
 aba:	81 e0       	ldi	r24, 0x01	; 1
 abc:	69 e0       	ldi	r22, 0x09	; 9
 abe:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <LcdMove>
        Display_Number_LCD( distance_1, 3 );      // 초음파센서 1 측정 거리 디스플레이 
 ac2:	80 91 5b 01 	lds	r24, 0x015B
 ac6:	90 91 5c 01 	lds	r25, 0x015C
 aca:	63 e0       	ldi	r22, 0x03	; 3
 acc:	0e 94 88 04 	call	0x910	; 0x910 <Display_Number_LCD>

		DC_Motor_PWM_L( duty_L );      // 왼쪽 DC Motor 정회전  
 ad0:	82 e3       	ldi	r24, 0x32	; 50
 ad2:	90 e0       	ldi	r25, 0x00	; 0
 ad4:	0e 94 64 01 	call	0x2c8	; 0x2c8 <DC_Motor_PWM_L>
		DC_Motor_PWM_R( -duty_R );     // 오른쪽 DC Motor 역회전  
 ad8:	8e ec       	ldi	r24, 0xCE	; 206
 ada:	9f ef       	ldi	r25, 0xFF	; 255
 adc:	0e 94 b5 01 	call	0x36a	; 0x36a <DC_Motor_PWM_R>
 ae0:	88 e8       	ldi	r24, 0x88	; 136
 ae2:	93 e1       	ldi	r25, 0x13	; 19
 ae4:	fe 01       	movw	r30, r28
 ae6:	31 97       	sbiw	r30, 0x01	; 1
 ae8:	f1 f7       	brne	.-4      	; 0xae6 <main+0x150>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 aea:	01 97       	sbiw	r24, 0x01	; 1
 aec:	d9 f7       	brne	.-10     	; 0xae4 <main+0x14e>

		DC_Motor_PWM_L( duty_L );      // 왼쪽 DC Motor 정회전  
		DC_Motor_PWM_R( -duty_R );     // 오른쪽 DC Motor 역회전  
        msec_delay( 5000 );          // 5초간 회전
 
		DC_Motor_PWM_L( 0 );         // 왼쪽 DC Motor 정지  
 aee:	80 e0       	ldi	r24, 0x00	; 0
 af0:	90 e0       	ldi	r25, 0x00	; 0
 af2:	0e 94 64 01 	call	0x2c8	; 0x2c8 <DC_Motor_PWM_L>
		DC_Motor_PWM_R( 0 );         // 오른쪽 DC Motor 정지  
 af6:	80 e0       	ldi	r24, 0x00	; 0
 af8:	90 e0       	ldi	r25, 0x00	; 0
 afa:	0e 94 b5 01 	call	0x36a	; 0x36a <DC_Motor_PWM_R>
 afe:	80 ed       	ldi	r24, 0xD0	; 208
 b00:	97 e0       	ldi	r25, 0x07	; 7
 b02:	fe 01       	movw	r30, r28
 b04:	31 97       	sbiw	r30, 0x01	; 1
 b06:	f1 f7       	brne	.-4      	; 0xb04 <main+0x16e>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 b08:	01 97       	sbiw	r24, 0x01	; 1
 b0a:	d9 f7       	brne	.-10     	; 0xb02 <main+0x16c>
 
		DC_Motor_PWM_L( 0 );         // 왼쪽 DC Motor 정지  
		DC_Motor_PWM_R( 0 );         // 오른쪽 DC Motor 정지  
        msec_delay( 2000 );          // 2초간 정지 

		DC_Motor_PWM_L( -duty_L );     // 왼쪽 DC Motor 역회전  
 b0c:	8e ec       	ldi	r24, 0xCE	; 206
 b0e:	9f ef       	ldi	r25, 0xFF	; 255
 b10:	0e 94 64 01 	call	0x2c8	; 0x2c8 <DC_Motor_PWM_L>
		DC_Motor_PWM_R( duty_R );      // 오른쪽 DC Motor 정회전  
 b14:	82 e3       	ldi	r24, 0x32	; 50
 b16:	90 e0       	ldi	r25, 0x00	; 0
 b18:	0e 94 b5 01 	call	0x36a	; 0x36a <DC_Motor_PWM_R>
 b1c:	88 e8       	ldi	r24, 0x88	; 136
 b1e:	93 e1       	ldi	r25, 0x13	; 19
 b20:	fe 01       	movw	r30, r28
 b22:	31 97       	sbiw	r30, 0x01	; 1
 b24:	f1 f7       	brne	.-4      	; 0xb22 <main+0x18c>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 b26:	01 97       	sbiw	r24, 0x01	; 1
 b28:	d9 f7       	brne	.-10     	; 0xb20 <main+0x18a>

		DC_Motor_PWM_L( -duty_L );     // 왼쪽 DC Motor 역회전  
		DC_Motor_PWM_R( duty_R );      // 오른쪽 DC Motor 정회전  
        msec_delay( 5000 );          // 5초간 회전
 
		DC_Motor_PWM_L( 0 );         // 왼쪽 DC Motor 정지  
 b2a:	80 e0       	ldi	r24, 0x00	; 0
 b2c:	90 e0       	ldi	r25, 0x00	; 0
 b2e:	0e 94 64 01 	call	0x2c8	; 0x2c8 <DC_Motor_PWM_L>
		DC_Motor_PWM_R( 0 );         // 오른쪽 DC Motor 정지  
 b32:	80 e0       	ldi	r24, 0x00	; 0
 b34:	90 e0       	ldi	r25, 0x00	; 0
 b36:	0e 94 b5 01 	call	0x36a	; 0x36a <DC_Motor_PWM_R>
 b3a:	80 ed       	ldi	r24, 0xD0	; 208
 b3c:	97 e0       	ldi	r25, 0x07	; 7
 b3e:	fe 01       	movw	r30, r28
 b40:	31 97       	sbiw	r30, 0x01	; 1
 b42:	f1 f7       	brne	.-4      	; 0xb40 <main+0x1aa>



void msec_delay(int n)
{	
	for(; n>0; n--)		// 1msec 시간 지연을 n회 반복
 b44:	01 97       	sbiw	r24, 0x01	; 1
 b46:	d9 f7       	brne	.-10     	; 0xb3e <main+0x1a8>
 b48:	84 e6       	ldi	r24, 0x64	; 100
 b4a:	90 e0       	ldi	r25, 0x00	; 0
 b4c:	fe 01       	movw	r30, r28
 b4e:	31 97       	sbiw	r30, 0x01	; 1
 b50:	f1 f7       	brne	.-4      	; 0xb4e <main+0x1b8>
 b52:	01 97       	sbiw	r24, 0x01	; 1
 b54:	d9 f7       	brne	.-10     	; 0xb4c <main+0x1b6>
 b56:	a8 cf       	rjmp	.-176    	; 0xaa8 <main+0x112>

00000b58 <__udivmodhi4>:
 b58:	aa 1b       	sub	r26, r26
 b5a:	bb 1b       	sub	r27, r27
 b5c:	51 e1       	ldi	r21, 0x11	; 17
 b5e:	07 c0       	rjmp	.+14     	; 0xb6e <__udivmodhi4_ep>

00000b60 <__udivmodhi4_loop>:
 b60:	aa 1f       	adc	r26, r26
 b62:	bb 1f       	adc	r27, r27
 b64:	a6 17       	cp	r26, r22
 b66:	b7 07       	cpc	r27, r23
 b68:	10 f0       	brcs	.+4      	; 0xb6e <__udivmodhi4_ep>
 b6a:	a6 1b       	sub	r26, r22
 b6c:	b7 0b       	sbc	r27, r23

00000b6e <__udivmodhi4_ep>:
 b6e:	88 1f       	adc	r24, r24
 b70:	99 1f       	adc	r25, r25
 b72:	5a 95       	dec	r21
 b74:	a9 f7       	brne	.-22     	; 0xb60 <__udivmodhi4_loop>
 b76:	80 95       	com	r24
 b78:	90 95       	com	r25
 b7a:	bc 01       	movw	r22, r24
 b7c:	cd 01       	movw	r24, r26
 b7e:	08 95       	ret

00000b80 <_exit>:
 b80:	f8 94       	cli

00000b82 <__stop_program>:
 b82:	ff cf       	rjmp	.-2      	; 0xb82 <__stop_program>
